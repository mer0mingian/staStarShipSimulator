{% extends "base.html" %}

{% block title %}{{ encounter.name }} - Player View{% endblock %}
{% block header %}{{ encounter.name }} - Round {{ encounter.round }}{% endblock %}

{% block content %}
{% if campaign %}
<!-- Campaign Breadcrumb -->
<div style="margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center;">
    <div>
        <a href="{{ url_for('campaigns.campaign_dashboard', campaign_id=campaign.campaign_id) }}"
           style="color: var(--lcars-purple); text-decoration: none;">
            {{ campaign.name }}
        </a>
        <span style="color: #666;"> / </span>
        <span style="color: var(--lcars-tan);">{{ encounter.name }}</span>
    </div>
</div>
{% endif %}

<!-- Turn Indicator Banner -->
<div id="turn-banner" class="turn-banner {% if encounter.current_turn == 'player' %}your-turn{% else %}enemy-turn{% endif %}">
    <div class="turn-text">
        {% if encounter.current_turn == 'player' %}
        YOUR TURN - Take one action
        {% else %}
        ENEMY TURN - Waiting for Game Master...
        {% endif %}
    </div>
    <div id="turn-counter" style="margin-top: 5px; font-size: 0.9em; display: flex; justify-content: center; gap: 30px;">
        <span style="color: var(--lcars-green);">
            Your Turns: <span id="player-turns-used">0</span> / <span id="player-turns-total">0</span>
        </span>
        <span style="color: var(--lcars-red);">
            Enemy: <span id="enemy-turns-used">0</span> / <span id="enemy-turns-total">0</span>
        </span>
    </div>
</div>

<div class="grid">
    <!-- Resource Pools (Read-only for player) -->
    <div class="panel">
        <h2>Resources</h2>
        <div class="resource-pool momentum">
            <span>Momentum</span>
            <span class="value" id="momentum">{{ encounter.momentum }}</span>
            <span style="color: #666;">/ 6</span>
        </div>
        <div class="resource-pool threat">
            <span>Threat</span>
            <span class="value" id="threat">{{ encounter.threat }}</span>
        </div>
        <div class="resource-pool" style="margin-top: 10px; padding: 8px; background: {{ '#1a3a1a' if player_ship.has_reserve_power else '#3a1a1a' }}; border: 2px solid {{ 'var(--lcars-green)' if player_ship.has_reserve_power else 'var(--lcars-red)' }}; border-radius: 5px;">
            <span style="color: {{ 'var(--lcars-green)' if player_ship.has_reserve_power else 'var(--lcars-red)' }};">Reserve Power</span>
            <span id="reserve-power-status" class="value" style="color: {{ 'var(--lcars-green)' if player_ship.has_reserve_power else 'var(--lcars-red)' }};">
                {{ '[AVAILABLE]' if player_ship.has_reserve_power else '[DEPLETED]' }}
            </span>
        </div>
        <div id="end-turn-section" style="margin-top: 15px; {% if encounter.current_turn != 'player' %}display: none;{% endif %}">
            <button class="btn" onclick="nextTurn()">End Turn</button>
        </div>
    </div>

    <!-- Player Character -->
    {% if player_char %}
    <div class="panel">
        <h2>{{ player_char.name }}</h2>
        <div class="stat-row">
            <span>Rank / Position</span>
            <span class="stat-value">{{ player_char.rank }} - {{ position.value.title() }}</span>
        </div>
        <div class="stat-row">
            <span>Stress</span>
            <span class="stat-value">{{ player_char.stress }} / {{ player_char.stress_max }}</span>
        </div>

        <h3 style="margin-top: 15px; color: var(--lcars-tan); font-size: 0.9em;">ATTRIBUTES</h3>
        <div class="stats-grid">
            <div class="stat-row">
                <span>Control</span>
                <span class="stat-value">{{ player_char.attributes.control }}</span>
            </div>
            <div class="stat-row">
                <span>Daring</span>
                <span class="stat-value">{{ player_char.attributes.daring }}</span>
            </div>
            <div class="stat-row">
                <span>Fitness</span>
                <span class="stat-value">{{ player_char.attributes.fitness }}</span>
            </div>
            <div class="stat-row">
                <span>Insight</span>
                <span class="stat-value">{{ player_char.attributes.insight }}</span>
            </div>
            <div class="stat-row">
                <span>Presence</span>
                <span class="stat-value">{{ player_char.attributes.presence }}</span>
            </div>
            <div class="stat-row">
                <span>Reason</span>
                <span class="stat-value">{{ player_char.attributes.reason }}</span>
            </div>
        </div>

        <h3 style="margin-top: 15px; color: var(--lcars-tan); font-size: 0.9em;">DISCIPLINES</h3>
        <div class="stats-grid">
            <div class="stat-row">
                <span>Command</span>
                <span class="stat-value">{{ player_char.disciplines.command }}</span>
            </div>
            <div class="stat-row">
                <span>Conn</span>
                <span class="stat-value">{{ player_char.disciplines.conn }}</span>
            </div>
            <div class="stat-row">
                <span>Engineering</span>
                <span class="stat-value">{{ player_char.disciplines.engineering }}</span>
            </div>
            <div class="stat-row">
                <span>Medicine</span>
                <span class="stat-value">{{ player_char.disciplines.medicine }}</span>
            </div>
            <div class="stat-row">
                <span>Science</span>
                <span class="stat-value">{{ player_char.disciplines.science }}</span>
            </div>
            <div class="stat-row">
                <span>Security</span>
                <span class="stat-value">{{ player_char.disciplines.security }}</span>
            </div>
        </div>

        <div style="margin-top: 10px; font-size: 0.9em; color: var(--lcars-tan);">
            <strong>Focuses:</strong> {{ player_char.focuses | join(', ') }}
        </div>
    </div>
    {% endif %}
</div>

<div class="grid">
    <!-- Player Ship -->
    {% if player_ship %}
    <div class="panel">
        <h2>{{ player_ship.name }}</h2>
        <div class="stat-row">
            <span>Class</span>
            <span class="stat-value">{{ player_ship.ship_class }}-class (Scale {{ player_ship.scale }})</span>
        </div>
        <div class="stat-row">
            <span>Shields</span>
            <span class="stat-value" id="player-shields">
                {{ player_ship.shields }} / {{ player_ship.shields_max }}
                <span id="shields-status" style="margin-left: 8px; font-size: 0.8em; {% if player_ship.shields_raised %}color: var(--lcars-green);{% else %}color: var(--lcars-red);{% endif %}">
                    [{{ 'ONLINE' if player_ship.shields_raised else 'OFFLINE' }}]
                </span>
            </span>
        </div>
        <div class="shields-bar">
            <div class="fill" id="player-shields-bar" style="width: {{ (player_ship.shields / player_ship.shields_max * 100) | int }}%;{% if not player_ship.shields_raised %} background: var(--lcars-red);{% endif %}"></div>
        </div>
        <div class="stat-row">
            <span>Resistance</span>
            <span class="stat-value" id="player-resistance">
                {{ player_ship.resistance }}{% if resistance_bonus > 0 %} <span style="color: var(--lcars-green);">(+{{ resistance_bonus }})</span>{% endif %}
            </span>
        </div>

        <h3 style="margin-top: 15px; color: var(--lcars-tan); font-size: 0.9em;">SYSTEMS</h3>
        <div class="stats-grid">
            {% set systems = [('Comms', player_ship.systems.comms, 'comms'), ('Computers', player_ship.systems.computers, 'computers'), ('Engines', player_ship.systems.engines, 'engines'), ('Sensors', player_ship.systems.sensors, 'sensors'), ('Structure', player_ship.systems.structure, 'structure'), ('Weapons', player_ship.systems.weapons, 'weapons')] %}
            {% for name, value, key in systems %}
            {% set breach_potency = player_ship.breaches | selectattr('system_name', 'equalto', key) | map(attribute='potency') | sum %}
            <div class="stat-row {% if breach_potency > 0 %}breached{% endif %}" data-system="{{ key }}">
                <span>{{ name }}</span>
                <span class="stat-value">
                    {{ value }}
                    <span class="breach-indicator" style="{% if breach_potency == 0 %}display:none{% endif %}">[Breach <span class="breach-count">{{ breach_potency }}</span>]</span>
                </span>
            </div>
            {% endfor %}
        </div>

        <h3 style="margin-top: 15px; color: var(--lcars-tan); font-size: 0.9em;">DEPARTMENTS</h3>
        <div class="stats-grid">
            <div class="stat-row"><span>Command</span><span class="stat-value">{{ player_ship.departments.command }}</span></div>
            <div class="stat-row"><span>Conn</span><span class="stat-value">{{ player_ship.departments.conn }}</span></div>
            <div class="stat-row"><span>Engineering</span><span class="stat-value">{{ player_ship.departments.engineering }}</span></div>
            <div class="stat-row"><span>Medicine</span><span class="stat-value">{{ player_ship.departments.medicine }}</span></div>
            <div class="stat-row"><span>Science</span><span class="stat-value">{{ player_ship.departments.science }}</span></div>
            <div class="stat-row"><span>Security</span><span class="stat-value">{{ player_ship.departments.security }}</span></div>
        </div>

        <h3 style="margin-top: 15px; color: var(--lcars-tan); font-size: 0.9em;">
            WEAPONS
            <span id="weapons-status" style="margin-left: 10px; {% if player_ship.weapons_armed %}color: var(--lcars-orange);{% else %}color: var(--lcars-red);{% endif %}">
                [{{ 'ARMED' if player_ship.weapons_armed else 'STANDBY' }}]
            </span>
        </h3>
        {% for weapon in player_ship.weapons %}
        <div class="stat-row">
            <span>{{ weapon.name }}</span>
            <span class="stat-value">Dmg {{ weapon.damage }}+{{ player_ship.weapons_damage_bonus() }} | {{ weapon.range.value.title() }}</span>
        </div>
        {% endfor %}
    </div>
    {% endif %}

    <!-- Enemy Ships (simplified for player view - names only) -->
    <div class="panel enemy-ship" style="border-color: var(--lcars-red);">
        <h2 style="color: var(--lcars-red);">ENEMY VESSELS</h2>
        <p style="color: var(--lcars-tan); font-size: 0.9em; margin-bottom: 10px;">Detected hostiles in sector:</p>
        {% for enemy in enemy_ships %}
        <div class="enemy-ship-item" data-ship-id="{{ loop.index0 }}" style="padding: 10px; background: #222; border-radius: 5px; margin: 5px 0; border-left: 3px solid var(--lcars-red);">
            <strong style="color: var(--lcars-red);">{{ enemy.name }}</strong>
            <div style="font-size: 0.85em; color: var(--lcars-tan);">
                {{ enemy.ship_class }}-class
            </div>
            <div class="stat-row" style="margin-top: 5px;">
                <span>Shields</span>
                <span class="stat-value enemy-shields">{{ enemy.shields }} / {{ enemy.shields_max }}</span>
            </div>
            <div class="shields-bar" style="height: 10px;">
                <div class="fill enemy-shields-bar" style="width: {{ (enemy.shields / enemy.shields_max * 100) | int }}%; background: var(--lcars-red);"></div>
            </div>
        </div>
        {% endfor %}
    </div>
</div>

<!-- Actions Panel (only visible on player turn) -->
<div id="actions-container" style="{% if encounter.current_turn != 'player' %}display: none;{% endif %}">
    <div style="margin-bottom: 10px; padding: 8px; background: #1a1a1a; border-radius: 5px; font-size: 0.85em;">
        <strong>Status Legend:</strong>
        <span class="status-badge status-done">DONE</span> Implemented & Tested
        <span class="status-badge status-rft">RFT</span> Ready For Testing
        <span class="status-badge status-not-impl">TODO</span> Not Yet Implemented
    </div>
    <div class="grid">
        <div class="panel">
            <h2>Minor Actions</h2>

            {% if actions.position_minor %}
            <h3 style="color: var(--lcars-orange); font-size: 0.9em; margin: 10px 0 5px 0;">{{ actions.position_name }} Specific</h3>
            <ul class="action-list">
                {% for action in actions.position_minor %}
                {% if action.name == 'Raise/Lower Shields' %}
                <li id="shields-action-btn" onclick="toggleShields()" class="" data-action-name="Raise Shields">
                    <strong>{{ 'Lower Shields' if player_ship.shields_raised else 'Raise Shields' }}</strong>
                    <span class="status-badge status-done">DONE</span>
                    <span class="breach-warning" style="display: none; color: var(--lcars-red); font-weight: bold;"></span>
                    <div class="action-type">{{ action.description[:80] }}...</div>
                </li>
                {% elif action.name == 'Arm/Disarm Weapons' %}
                <li id="weapons-action-btn" onclick="toggleWeapons()" class="" data-action-name="Arm Weapons">
                    <strong>{{ 'Disarm Weapons' if player_ship.weapons_armed else 'Arm Weapons' }}</strong>
                    <span class="status-badge status-done">DONE</span>
                    <span class="breach-warning" style="display: none; color: var(--lcars-red); font-weight: bold;"></span>
                    <div class="action-type">{{ action.description[:80] }}...</div>
                </li>
                {% else %}
                <li onclick="selectAction('{{ action.name }}', 'minor', {{ action.difficulty }})"
                    data-action-name="{{ action.name }}"
                    class="{% if action.status == 'NOT_IMPL' %}action-not-impl{% endif %}">
                    <strong>{{ action.name }}</strong>
                    {% if action.status == 'DONE' %}
                    <span class="status-badge status-done">DONE</span>
                    {% elif action.status == 'RFT' %}
                    <span class="status-badge status-rft">RFT</span>
                    {% else %}
                    <span class="status-badge status-not-impl">TODO</span>
                    {% endif %}
                    <span class="breach-warning" style="display: none; color: var(--lcars-red); font-weight: bold;"></span>
                    <div class="action-type">{{ action.description[:80] }}...</div>
                </li>
                {% endif %}
                {% endfor %}
            </ul>
            {% endif %}

            <h3 style="color: var(--lcars-tan); font-size: 0.9em; margin: 10px 0 5px 0;">Standard</h3>
            <ul class="action-list">
                {% for action in actions.standard_minor %}
                <li onclick="selectAction('{{ action.name }}', 'minor', {{ action.difficulty }})"
                    data-action-name="{{ action.name }}"
                    class="{% if action.status == 'NOT_IMPL' %}action-not-impl{% endif %}">
                    <strong>{{ action.name }}</strong>
                    {% if action.status == 'DONE' %}
                    <span class="status-badge status-done">DONE</span>
                    {% elif action.status == 'RFT' %}
                    <span class="status-badge status-rft">RFT</span>
                    {% else %}
                    <span class="status-badge status-not-impl">TODO</span>
                    {% endif %}
                    <span class="breach-warning" style="display: none; color: var(--lcars-red); font-weight: bold;"></span>
                    <div class="action-type">{{ action.description[:80] }}...</div>
                </li>
                {% endfor %}
            </ul>
        </div>

        <div class="panel">
            <h2>Major Actions</h2>

            {% if actions.position_major %}
            <h3 style="color: var(--lcars-orange); font-size: 0.9em; margin: 10px 0 5px 0;">{{ actions.position_name }} Specific</h3>
            <ul class="action-list">
                {% for action in actions.position_major %}
                <li onclick="selectAction('{{ action.name }}', 'major', {{ action.difficulty }})"
                    data-action-name="{{ action.name }}"
                    data-base-difficulty="{{ action.difficulty }}"
                    class="{% if action.name == 'Fire' %}fire-action{% endif %} {% if action.status == 'NOT_IMPL' %}action-not-impl{% endif %}">
                    <strong>{{ action.name }}</strong>
                    {% if action.status == 'DONE' %}
                    <span class="status-badge status-done">DONE</span>
                    {% elif action.status == 'RFT' %}
                    <span class="status-badge status-rft">RFT</span>
                    {% else %}
                    <span class="status-badge status-not-impl">TODO</span>
                    {% endif %}
                    {% if action.difficulty > 0 %}
                    <span class="difficulty-display" style="color: var(--lcars-tan);">(Diff {{ action.difficulty }})</span>
                    {% endif %}
                    <span class="breach-warning" style="display: none; color: var(--lcars-red); font-weight: bold;"></span>
                    <div class="action-type">{{ action.description[:80] }}...</div>
                </li>
                {% endfor %}
            </ul>
            {% endif %}

            <h3 style="color: var(--lcars-tan); font-size: 0.9em; margin: 10px 0 5px 0;">Standard</h3>
            <ul class="action-list">
                {% for action in actions.standard_major %}
                <li onclick="selectAction('{{ action.name }}', 'major', {{ action.difficulty }})"
                    data-action-name="{{ action.name }}"
                    data-base-difficulty="{{ action.difficulty }}"
                    class="{% if action.name == 'Fire' %}fire-action{% endif %} {% if action.status == 'NOT_IMPL' %}action-not-impl{% endif %}">
                    <strong>{{ action.name }}</strong>
                    {% if action.status == 'DONE' %}
                    <span class="status-badge status-done">DONE</span>
                    {% elif action.status == 'RFT' %}
                    <span class="status-badge status-rft">RFT</span>
                    {% else %}
                    <span class="status-badge status-not-impl">TODO</span>
                    {% endif %}
                    {% if action.difficulty > 0 %}
                    <span class="difficulty-display" style="color: var(--lcars-tan);">(Diff {{ action.difficulty }})</span>
                    {% endif %}
                    <span class="breach-warning" style="display: none; color: var(--lcars-red); font-weight: bold;"></span>
                    <div class="action-type">{{ action.description[:80] }}...</div>
                </li>
                {% endfor %}
            </ul>
        </div>
    </div>
</div>

<!-- Selected Actions Summary -->
<div class="panel" id="selection-summary" style="display: none; border-color: var(--lcars-blue);">
    <h2 style="color: var(--lcars-blue);">SELECTED ACTIONS</h2>
    <div class="grid" style="grid-template-columns: 1fr 1fr; gap: 15px;">
        <div>
            <strong style="color: var(--lcars-tan);">Minor Action:</strong>
            <div id="summary-minor" style="padding: 8px; background: #222; border-radius: 5px; margin-top: 5px;">
                <span style="color: #666;">None selected</span>
            </div>
        </div>
        <div>
            <strong style="color: var(--lcars-tan);">Major Action:</strong>
            <div id="summary-major" style="padding: 8px; background: #222; border-radius: 5px; margin-top: 5px;">
                <span style="color: #666;">None selected</span>
            </div>
        </div>
    </div>
</div>

<!-- Fire Action Panel (hidden by default) -->
<div class="panel" id="fire-panel" style="display: none; border-color: var(--lcars-red);">
    <h2 style="color: var(--lcars-red);">FIRE WEAPONS</h2>

    <!-- Active Minor Action Banner -->
    <div id="fire-minor-action-banner" style="display: none; margin-bottom: 15px; padding: 10px; background: #1a3a3a; border: 2px solid var(--lcars-blue); border-radius: 5px;">
        <strong style="color: var(--lcars-blue);">MINOR ACTION ACTIVE:</strong>
        <span id="fire-minor-action-name" style="color: var(--lcars-green);"></span>
        <div id="fire-minor-action-effects" style="font-size: 0.9em; margin-top: 5px; color: var(--lcars-tan);"></div>
    </div>

    <div class="grid" style="grid-template-columns: 1fr 1fr;">
        <div>
            <label for="weapon-select">Select Weapon</label>
            <select id="weapon-select" style="width: 100%;">
                {% for weapon in player_ship.weapons %}
                <option value="{{ loop.index0 }}"
                        data-damage="{{ weapon.damage }}"
                        data-type="{{ weapon.weapon_type.value }}"
                        data-range="{{ weapon.range.value }}">
                    {{ weapon.name }} (Dmg {{ weapon.damage }}+{{ player_ship.weapons_damage_bonus() }}, {{ weapon.range.value.title() }})
                </option>
                {% endfor %}
            </select>
        </div>
        <div>
            <label for="target-select">Select Target</label>
            <select id="target-select" style="width: 100%;">
                {% for enemy in enemy_ships %}
                <option value="{{ loop.index0 }}">{{ enemy.name }}</option>
                {% endfor %}
            </select>
        </div>
    </div>

    <!-- Targeting Solution Info (only visible when Targeting Solution is active) -->
    <div id="targeting-solution-panel" style="display: none; margin-top: 15px; padding: 10px; background: #1a2a1a; border: 2px solid var(--lcars-green); border-radius: 5px;">
        <strong style="color: var(--lcars-green);">TARGETING SOLUTION ACTIVE</strong>
        <div style="margin-top: 8px; font-size: 0.9em; color: var(--lcars-tan);">
            After rolling, you may choose ONE benefit:
            <ul style="margin: 5px 0 0 20px;">
                <li><strong>Re-roll 1d20</strong> - Click on any die to re-roll it</li>
                <li><strong>Choose System</strong> - If you cause a breach, pick which system is hit</li>
            </ul>
            <div style="margin-top: 8px; color: var(--lcars-orange);">
                Using re-roll consumes Targeting Solution (no system choice)
            </div>
        </div>
    </div>

    <div style="margin-top: 15px; padding: 10px; background: #222; border-radius: 5px;">
        <strong>Attack Details:</strong>
        <div id="attack-details">
            <p><strong>Character Roll (2d20):</strong> Control ({{ player_char.attributes.control if player_char else 9 }}) + Security ({{ player_char.disciplines.security if player_char else 3 }}) = Target {{ (player_char.attributes.control + player_char.disciplines.security) if player_char else 12 }}</p>
            <p><strong>Ship Assist (1d20):</strong> Weapons ({{ player_ship.systems.weapons if player_ship else 7 }}) + Security ({{ player_ship.departments.security if player_ship else 2 }}) = Target {{ (player_ship.systems.weapons + player_ship.departments.security) if player_ship else 9 }}</p>
            <p>Difficulty: <span id="fire-difficulty">2</span> (Energy) / 3 (Torpedo)</p>
            <p>Total Damage: <span id="fire-damage">{{ player_ship.weapons[0].damage + player_ship.weapons_damage_bonus() if player_ship.weapons else 0 }}</span></p>
        </div>
    </div>

    <div style="margin-top: 15px;">
        <label>
            <input type="checkbox" id="fire-focus"> Focus Applies (Targeting Systems, etc.)
        </label>
    </div>
    <div id="fire-bonus-section" style="display: none;">
        <label for="fire-bonus">Bonus Dice (Cost: 1st=1, 2nd=2, 3rd=3 Momentum)</label>
        <input type="number" id="fire-bonus" value="0" min="0" max="0" style="width: 80px;">
    </div>

    <button class="btn" onclick="executeFireAction()" style="margin-top: 15px;">FIRE!</button>
    <button class="btn" onclick="cancelAction()" style="margin-top: 15px; background: #666;">Cancel</button>

    <div id="fire-results" style="margin-top: 15px; display: none;"></div>
</div>

<!-- Incoming Attack Alert Panel (shown when enemy attacks while Defensive Fire is active) -->
<div class="panel" id="incoming-attack-panel" style="display: none; border-color: var(--lcars-red); background: #2a1a1a;">
    <h2 style="color: var(--lcars-red);">INCOMING ATTACK!</h2>

    <div style="padding: 15px; background: #3a1a1a; border: 2px solid var(--lcars-red); border-radius: 5px; margin-bottom: 15px;">
        <p style="margin: 0; color: var(--lcars-orange); font-size: 1.2em;">
            <strong id="incoming-attacker">Enemy Ship</strong> is attacking with <strong id="incoming-weapon">Phasers</strong>!
        </p>
        <p style="margin: 10px 0 0 0; color: var(--lcars-tan);">
            Your <strong>Defensive Fire</strong> is active. Make your opposed roll to defend!
        </p>
    </div>

    <div style="padding: 10px; background: #222; border-radius: 5px; margin-bottom: 15px;">
        <strong>Your Defensive Roll:</strong> Daring + Security (Target <span id="incoming-defender-target">12</span>)
        <br>
        <strong>Ship Assist:</strong> Weapons + Security (Target <span id="incoming-ship-target">9</span>)
    </div>

    <div style="margin-bottom: 15px;">
        <button class="btn" onclick="rollDefensiveDice()" style="background: var(--lcars-purple); font-size: 1.1em; padding: 15px 30px;">
            ROLL DEFENSIVE DICE
        </button>
    </div>

    <div id="incoming-roll-results" style="display: none; padding: 15px; background: #1a2a3a; border: 2px solid var(--lcars-blue); border-radius: 5px;">
        <h3 style="color: var(--lcars-blue); margin-top: 0;">Roll Results</h3>
        <div id="incoming-roll-details"></div>
        <button class="btn" onclick="submitDefensiveRoll()" style="margin-top: 15px; background: var(--lcars-green);">
            SUBMIT ROLL
        </button>
    </div>

    <div id="incoming-attack-resolution" style="display: none; margin-top: 15px;"></div>
</div>

<!-- Defensive Fire Action Panel (hidden by default) -->
<div class="panel" id="defensive-fire-panel" style="display: none; border-color: var(--lcars-purple);">
    <h2 style="color: var(--lcars-purple);">DEFENSIVE FIRE</h2>

    <div style="padding: 10px; background: #2a1a3a; border: 2px solid var(--lcars-purple); border-radius: 5px; margin-bottom: 15px;">
        <p style="margin: 0; color: var(--lcars-tan);">
            Choose an <strong>energy weapon</strong> to use defensively. Until your next turn,
            enemy attacks against this ship become <strong>opposed rolls</strong>.
        </p>
        <p style="margin: 10px 0 0 0; color: var(--lcars-orange);">
            If you win the opposed roll, you may spend <strong>2 Momentum</strong> to counterattack with this weapon.
        </p>
    </div>

    <!-- Momentum Warning (shown when momentum is low) -->
    <div id="defensive-fire-momentum-warning" style="display: none; padding: 10px; background: #3a2a1a; border: 2px solid var(--lcars-orange); border-radius: 5px; margin-bottom: 15px;">
        <p style="margin: 0; color: var(--lcars-orange);">
            <strong>WARNING:</strong> You currently have <span id="df-current-momentum">0</span> Momentum.
            If you activate Defensive Fire now, you won't have enough Momentum (2 required) to counterattack on the next enemy attack.
        </p>
    </div>

    <div>
        <label for="defensive-fire-weapon-select">Select Energy Weapon</label>
        <select id="defensive-fire-weapon-select" style="width: 100%;">
            {% for weapon in player_ship.weapons %}
            {% if weapon.weapon_type.value != 'torpedo' %}
            <option value="{{ loop.index0 }}" data-damage="{{ weapon.damage }}">
                {{ weapon.name }} (Dmg {{ weapon.damage }}+{{ player_ship.weapons_damage_bonus() }}, {{ weapon.range.value.title() }})
            </option>
            {% endif %}
            {% endfor %}
        </select>
    </div>

    <div style="margin-top: 15px; padding: 10px; background: #222; border-radius: 5px;">
        <strong>Opposed Roll Details:</strong>
        <p><strong>Your Roll:</strong> Daring ({{ player_char.attributes.daring if player_char else 9 }}) + Security ({{ player_char.disciplines.security if player_char else 3 }}) = Target {{ (player_char.attributes.daring + player_char.disciplines.security) if player_char else 12 }}</p>
        <p><strong>Ship Assist:</strong> Weapons ({{ player_ship.systems.weapons if player_ship else 7 }}) + Security ({{ player_ship.departments.security if player_ship else 2 }}) = Target {{ (player_ship.systems.weapons + player_ship.departments.security) if player_ship else 9 }}</p>
    </div>

    <button class="btn" onclick="executeDefensiveFire()" style="margin-top: 15px; background: var(--lcars-purple);">ACTIVATE DEFENSIVE FIRE</button>
    <button class="btn" onclick="cancelAction()" style="margin-top: 15px; background: #666;">Cancel</button>

    <div id="defensive-fire-results" style="margin-top: 15px; display: none;"></div>
</div>

<!-- Reroute Power Action Panel (hidden by default) -->
<div class="panel" id="reroute-power-panel" style="display: none; border-color: var(--lcars-orange);">
    <h2 style="color: var(--lcars-orange);">REROUTE POWER</h2>

    <div style="padding: 10px; background: #2a2a1a; border: 2px solid var(--lcars-orange); border-radius: 5px; margin-bottom: 15px;">
        <p style="margin: 0; color: var(--lcars-tan);">
            Reroute power to a specific ship system. The <strong>next action</strong> using that system
            gets <strong>-1 Difficulty</strong>.
        </p>
        <p style="margin: 10px 0 0 0; color: var(--lcars-red);">
            <strong>Consumes Reserve Power!</strong>
        </p>
    </div>

    <!-- Reserve Power Warning -->
    <div id="reroute-no-power-warning" style="display: none; padding: 10px; background: #3a1a1a; border: 2px solid var(--lcars-red); border-radius: 5px; margin-bottom: 15px;">
        <p style="margin: 0; color: var(--lcars-red);">
            <strong>NO RESERVE POWER!</strong> You must use Regain Power first.
        </p>
    </div>

    <div>
        <label for="reroute-system-select">Select Target System</label>
        <select id="reroute-system-select" style="width: 100%;">
            <option value="weapons">WEAPONS - Boost Fire, Defensive Fire</option>
            <option value="sensors">SENSORS - Boost Scan, Sensor Sweep</option>
            <option value="engines">ENGINES - Boost Maneuver, Impulse, Warp</option>
            <option value="structure">STRUCTURE - Boost Regenerate Shields, Tractor Beam</option>
            <option value="comms">COMMS - Boost Hail, Communications</option>
            <option value="computers">COMPUTERS - Boost Computer-assisted tasks</option>
        </select>
    </div>

    <div style="margin-top: 15px; padding: 10px; background: #222; border-radius: 5px;">
        <strong>Effect:</strong> Next action using <span id="reroute-target-display">WEAPONS</span> gets <span style="color: var(--lcars-green);">-1 Difficulty</span>
    </div>

    <button class="btn" onclick="executeReroutePower()" style="margin-top: 15px; background: var(--lcars-orange);">REROUTE POWER</button>
    <button class="btn" onclick="cancelAction()" style="margin-top: 15px; background: #666;">Cancel</button>

    <div id="reroute-power-results" style="margin-top: 15px; display: none;"></div>
</div>

<!-- Damage Control Panel -->
<div class="panel" id="damage-control-panel" style="display: none; border-color: var(--lcars-green);">
    <h2 style="color: var(--lcars-green);">DAMAGE CONTROL</h2>

    <div style="padding: 10px; background: #1a2a1a; border: 2px solid var(--lcars-green); border-radius: 5px; margin-bottom: 15px;">
        <p style="margin: 0; color: var(--lcars-tan);">
            Direct repair teams to patch a breach. Select which system to repair, then roll to succeed.
        </p>
        <p style="margin: 10px 0 0 0; color: var(--lcars-orange);">
            <strong>Difficulty:</strong> 2 + Breach Potency on target system
        </p>
    </div>

    <!-- No Breaches Warning -->
    <div id="damage-control-no-breach-warning" style="display: none; padding: 10px; background: #3a1a1a; border: 2px solid var(--lcars-red); border-radius: 5px; margin-bottom: 15px;">
        <p style="margin: 0; color: var(--lcars-red);">
            <strong>NO BREACHES!</strong> There are no breaches to repair.
        </p>
    </div>

    <div id="damage-control-system-section">
        <label for="damage-control-system-select">Select System to Repair</label>
        <select id="damage-control-system-select" style="width: 100%;" onchange="updateDamageControlDisplay()">
            <!-- Options populated dynamically based on breaches -->
        </select>
    </div>

    <div style="margin-top: 15px; padding: 10px; background: #222; border-radius: 5px;">
        <strong>Roll Details:</strong>
        <p><strong>Character Roll (2d20):</strong> Presence ({{ player_char.attributes.presence if player_char else 9 }}) + Engineering ({{ player_char.disciplines.engineering if player_char else 3 }}) = Target {{ (player_char.attributes.presence + player_char.disciplines.engineering) if player_char else 12 }}</p>
        <p>Base Difficulty: <strong>2</strong> + <span id="damage-control-breach-potency">0</span> (breach potency) = <strong id="damage-control-total-difficulty">2</strong></p>
    </div>

    <div style="margin-top: 15px;">
        <label>
            <input type="checkbox" id="damage-control-focus"> Focus Applies (Damage Control, etc.)
        </label>
    </div>
    <div id="damage-control-bonus-section" style="display: none;">
        <label for="damage-control-bonus">Bonus Dice (Cost: 1st=1, 2nd=2, 3rd=3 Momentum)</label>
        <input type="number" id="damage-control-bonus" value="0" min="0" max="0" style="width: 80px;">
    </div>

    <button class="btn" onclick="executeDamageControlRoll()" style="margin-top: 15px; background: var(--lcars-green);">ROLL DAMAGE CONTROL</button>
    <button class="btn" onclick="cancelAction()" style="margin-top: 15px; background: #666;">Cancel</button>

    <div id="damage-control-results" style="margin-top: 15px; display: none;"></div>
</div>

<!-- Ram Action Panel -->
<div class="panel" id="ram-panel" style="display: none; border-color: var(--lcars-orange);">
    <h2 style="color: var(--lcars-orange);">RAM TARGET</h2>

    <div style="margin-bottom: 15px; padding: 10px; background: #2a1a0a; border: 2px solid var(--lcars-orange); border-radius: 5px;">
        <strong style="color: var(--lcars-orange);">WARNING:</strong>
        <span style="color: var(--lcars-tan);">Ramming deals collision damage to BOTH ships! Your ship will also take damage.</span>
    </div>

    <div>
        <label for="ram-target-select">Select Target</label>
        <select id="ram-target-select" style="width: 100%;">
            {% for enemy in enemy_ships %}
            <option value="{{ loop.index0 }}" data-scale="{{ enemy.scale }}">{{ enemy.name }} (Scale {{ enemy.scale }})</option>
            {% endfor %}
        </select>
    </div>

    <div style="margin-top: 15px; padding: 10px; background: #222; border-radius: 5px;">
        <strong>Ram Details:</strong>
        <div id="ram-details">
            <p><strong>Character Roll (2d20):</strong> Daring ({{ player_char.attributes.daring if player_char else 9 }}) + Conn ({{ player_char.disciplines.conn if player_char else 3 }}) = Target {{ (player_char.attributes.daring + player_char.disciplines.conn) if player_char else 12 }}</p>
            <p><strong>Ship Assist (1d20):</strong> Engines ({{ player_ship.systems.engines if player_ship else 7 }}) + Conn ({{ player_ship.departments.conn if player_ship else 2 }}) = Target {{ (player_ship.systems.engines + player_ship.departments.conn) if player_ship else 9 }}</p>
            <p>Difficulty: <strong>2</strong></p>
            <p style="margin-top: 10px; color: var(--lcars-orange);">
                <strong>Your Collision Damage:</strong> <span id="ram-your-damage">{{ player_ship.scale if player_ship else 4 }}</span> (Scale {{ player_ship.scale if player_ship else 4 }})
            </p>
            <p style="color: var(--lcars-red);">
                <strong>Damage You'll Take:</strong> <span id="ram-their-damage">{{ enemy_ships[0].scale if enemy_ships else 3 }}</span> (Target's Scale)
            </p>
            <p style="font-size: 0.9em; color: var(--lcars-tan); margin-top: 10px;">
                * Collision damage has <strong>Piercing</strong> (ignores resistance)
            </p>
        </div>
    </div>

    <div style="margin-top: 15px;">
        <label>
            <input type="checkbox" id="ram-focus"> Focus Applies (Precision Flying, etc.)
        </label>
    </div>
    <div id="ram-bonus-section" style="display: none;">
        <label for="ram-bonus">Bonus Dice (Cost: 1st=1, 2nd=2, 3rd=3 Momentum)</label>
        <input type="number" id="ram-bonus" value="0" min="0" max="0" style="width: 80px;">
    </div>

    <button class="btn" onclick="executeRamAction()" style="margin-top: 15px; background: var(--lcars-orange);">RAM!</button>
    <button class="btn" onclick="cancelAction()" style="margin-top: 15px; background: #666;">Cancel</button>

    <div id="ram-results" style="margin-top: 15px; display: none;"></div>
</div>

<!-- Generic Dice Roller (for non-Fire actions) - hidden until major action selected -->
<div class="panel" id="dice-panel" style="display: none;">
    <h2>Dice Roller</h2>
    <div id="current-action-display" style="margin-bottom: 15px; padding: 10px; background: #222; border-radius: 5px; display: none;">
        <strong>Current Action:</strong> <span id="current-action-name"></span>
    </div>

    <!-- Roll details from action config (read-only) -->
    <div id="roll-details" style="margin-bottom: 15px; padding: 10px; background: #222; border-radius: 5px;">
        <p><strong>Character Roll (2d20):</strong> <span id="roll-attr-name">Control</span> (<span id="roll-attr-value">9</span>) + <span id="roll-disc-name">Engineering</span> (<span id="roll-disc-value">2</span>) = Target <span id="roll-target">11</span></p>
        <p id="ship-assist-row" style="display: none;"><strong>Ship Assist (1d20):</strong> <span id="ship-assist-system-name">Structure</span> (<span id="ship-assist-system-value">7</span>) + <span id="ship-assist-dept-name">Engineering</span> (<span id="ship-assist-dept-value">2</span>) = Target <span id="ship-assist-target">9</span></p>
        <p><strong>Difficulty:</strong> <span id="roll-diff-display">1</span></p>
    </div>

    <!-- Hidden inputs to store actual values -->
    <input type="hidden" id="roll-attr" value="9">
    <input type="hidden" id="roll-disc" value="2">
    <input type="hidden" id="roll-diff" value="1">

    <div class="grid" style="grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));">
        <div id="roll-bonus-section" style="display: none;">
            <label for="roll-bonus">Bonus Dice (Cost: 1st=1, 2nd=2, 3rd=3 Momentum)</label>
            <input type="number" id="roll-bonus" value="0" min="0" max="0" style="width: 100%;">
        </div>
        <div>
            <label>
                <input type="checkbox" id="roll-focus"> Focus Applies
            </label>
        </div>
    </div>
    <button class="btn" onclick="rollDice()" style="margin-top: 15px;">Roll Dice</button>

    <div id="dice-results" style="margin-top: 15px; display: none;">
        <h3>Results</h3>
        <div id="dice-display"></div>
        <div id="dice-summary" style="margin-top: 10px;"></div>
    </div>
</div>

<style>
    .stats-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 0 15px;
    }
    .breached {
        color: var(--lcars-red) !important;
    }
    .breach-indicator {
        color: var(--lcars-red);
        font-size: 0.8em;
        margin-left: 5px;
    }
    .fire-action {
        border-left: 3px solid var(--lcars-red) !important;
    }
    .fire-action-highlighted {
        background: rgba(255, 100, 100, 0.2) !important;
        border: 2px solid var(--lcars-red) !important;
        animation: pulse-fire 1.5s ease-in-out infinite;
    }
    @keyframes pulse-fire {
        0%, 100% { box-shadow: 0 0 5px var(--lcars-red); }
        50% { box-shadow: 0 0 15px var(--lcars-red); }
    }
    @keyframes fadeIn {
        from { opacity: 0; transform: translateY(-10px); }
        to { opacity: 1; transform: translateY(0); }
    }
    @keyframes fadeOut {
        from { opacity: 1; transform: translateY(0); }
        to { opacity: 0; transform: translateY(-10px); }
    }
    /* Selected action highlighting */
    .action-selected {
        background: rgba(153, 204, 255, 0.3) !important;
        border: 2px solid var(--lcars-blue) !important;
        box-shadow: 0 0 10px var(--lcars-blue);
    }
    .action-selected::before {
        content: "OK ";
        color: var(--lcars-green);
    }
    /* Action status badges */
    .status-badge {
        display: inline-block;
        padding: 2px 6px;
        border-radius: 3px;
        font-size: 0.7em;
        font-weight: bold;
        margin-left: 8px;
        vertical-align: middle;
    }
    .status-done {
        background: var(--lcars-green);
        color: #000;
    }
    .status-rft {
        background: var(--lcars-orange);
        color: #000;
    }
    .status-not-impl {
        background: #666;
        color: #ccc;
    }
    .action-not-impl {
        opacity: 0.5;
    }
    .action-disabled {
        opacity: 0.4;
        pointer-events: none;
        position: relative;
    }
    .action-disabled::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: repeating-linear-gradient(
            45deg,
            transparent,
            transparent 10px,
            rgba(255, 0, 0, 0.1) 10px,
            rgba(255, 0, 0, 0.1) 20px
        );
    }
    .action-disabled .breach-warning {
        display: inline !important;
    }
    .breach-modifier {
        color: var(--lcars-orange) !important;
        font-weight: bold;
    }
    .damage-report {
        padding: 15px;
        background: #222;
        border-radius: 5px;
        margin-top: 10px;
    }
    .damage-report h4 {
        color: var(--lcars-red);
        margin-bottom: 10px;
    }
    /* Turn banner styles */
    .turn-banner {
        padding: 15px 20px;
        border-radius: 10px;
        text-align: center;
        margin-bottom: 20px;
        font-size: 1.2em;
        font-weight: bold;
        text-transform: uppercase;
        letter-spacing: 2px;
    }
    .turn-banner.your-turn {
        background: linear-gradient(135deg, #1a3a1a, #2a5a2a);
        border: 3px solid var(--lcars-green);
        color: var(--lcars-green);
        animation: pulse-green 2s ease-in-out infinite;
    }
    .turn-banner.enemy-turn {
        background: linear-gradient(135deg, #3a1a1a, #5a2a2a);
        border: 3px solid var(--lcars-red);
        color: var(--lcars-red);
    }
    @keyframes pulse-green {
        0%, 100% { box-shadow: 0 0 10px var(--lcars-green); }
        50% { box-shadow: 0 0 25px var(--lcars-green); }
    }
</style>
{% endblock %}

{% block scripts %}
<script>
    const encounterId = '{{ encounter.encounter_id }}';
    const playerShipId = {{ player_ship_db_id if player_ship_db_id else 'null' }};
    const playerCharId = {{ player_char_db_id if player_char_db_id else 'null' }};
    const enemyShipIds = {{ enemy_ship_db_ids | tojson if enemy_ship_db_ids else '[]' }};
    const weaponsBonus = {{ player_ship.weapons_damage_bonus() if player_ship else 0 }};
    const role = 'player';
    let currentTurn = '{{ encounter.current_turn }}';

    // Resistance tracking
    const baseResistance = {{ player_ship.resistance if player_ship else 4 }};
    let currentResistanceBonus = {{ resistance_bonus if resistance_bonus else 0 }};

    function updateResistanceDisplay() {
        const el = document.getElementById('player-resistance');
        if (currentResistanceBonus > 0) {
            el.innerHTML = `${baseResistance} <span style="color: var(--lcars-green);">(+${currentResistanceBonus})</span>`;
        } else {
            el.innerHTML = `${baseResistance}`;
        }
    }

    // Shields tracking
    let shieldsRaised = {{ 'true' if player_ship.shields_raised else 'false' }};
    const shieldsMax = {{ player_ship.shields_max if player_ship else 9 }};

    function updateShieldsDisplay(shields, raised) {
        shieldsRaised = raised;

        // Update shields value
        const shieldsEl = document.getElementById('player-shields');
        const barEl = document.getElementById('player-shields-bar');

        // Update text
        shieldsEl.innerHTML = `${shields} / ${shieldsMax} <span id="shields-status" style="margin-left: 8px; font-size: 0.8em; color: var(--lcars-${raised ? 'green' : 'red'});">[${raised ? 'ONLINE' : 'OFFLINE'}]</span>`;

        // Update bar
        barEl.style.width = `${(shields / shieldsMax) * 100}%`;
        barEl.style.background = raised ? '' : 'var(--lcars-red)';

        // Update action button text
        updateShieldActionButton();
    }

    function updateShieldActionButton() {
        const btn = document.getElementById('shields-action-btn');
        if (btn) {
            btn.querySelector('strong').textContent = shieldsRaised ? 'Lower Shields' : 'Raise Shields';
        }
    }

    async function toggleShields() {
        if (currentTurn !== 'player') {
            showErrorToast("It's not your turn!");
            return;
        }
        const actionName = shieldsRaised ? 'Lower Shields' : 'Raise Shields';
        const response = await fetch(`/api/encounter/${encounterId}/execute-action`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ action_name: actionName, character_id: playerCharId })
        });
        const data = await response.json();

        if (data.success) {
            updateShieldsDisplay(data.shields, data.shields_raised);
            selectedMinorAction = actionName;
            highlightAction(actionName, 'minor');
            updateSelectionSummary();
            showMinorActionResult(data.message);
        }
    }

    // Weapons tracking
    let weaponsArmed = {{ 'true' if player_ship.weapons_armed else 'false' }};

    // Reserve Power tracking
    let hasReservePower = {{ 'true' if player_ship.has_reserve_power else 'false' }};

    function updateWeaponsDisplay(armed) {
        weaponsArmed = armed;
        const statusEl = document.getElementById('weapons-status');
        statusEl.textContent = `[${armed ? 'ARMED' : 'STANDBY'}]`;
        statusEl.style.color = armed ? 'var(--lcars-orange)' : 'var(--lcars-red)';

        // Update action button text
        updateWeaponsActionButton();
    }

    function updateWeaponsActionButton() {
        const btn = document.getElementById('weapons-action-btn');
        if (btn) {
            btn.querySelector('strong').textContent = weaponsArmed ? 'Disarm Weapons' : 'Arm Weapons';
        }
    }

    async function toggleWeapons() {
        if (currentTurn !== 'player') {
            showErrorToast("It's not your turn!");
            return;
        }
        const actionName = weaponsArmed ? 'Disarm Weapons' : 'Arm Weapons';
        const response = await fetch(`/api/encounter/${encounterId}/execute-action`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ action_name: actionName, character_id: playerCharId })
        });
        const data = await response.json();

        if (data.success) {
            updateWeaponsDisplay(data.weapons_armed);
            selectedMinorAction = actionName;
            highlightAction(actionName, 'minor');
            updateSelectionSummary();
            showMinorActionResult(data.message);
        }
    }

    // Player stats for reference
    const playerAttrs = {
        control: {{ player_char.attributes.control if player_char else 9 }},
        daring: {{ player_char.attributes.daring if player_char else 9 }},
        fitness: {{ player_char.attributes.fitness if player_char else 9 }},
        insight: {{ player_char.attributes.insight if player_char else 9 }},
        presence: {{ player_char.attributes.presence if player_char else 9 }},
        reason: {{ player_char.attributes.reason if player_char else 9 }}
    };
    const playerDiscs = {
        command: {{ player_char.disciplines.command if player_char else 2 }},
        conn: {{ player_char.disciplines.conn if player_char else 2 }},
        engineering: {{ player_char.disciplines.engineering if player_char else 2 }},
        medicine: {{ player_char.disciplines.medicine if player_char else 2 }},
        science: {{ player_char.disciplines.science if player_char else 2 }},
        security: {{ player_char.disciplines.security if player_char else 2 }}
    };

    // Ship stats for assist rolls
    const shipSystems = {
        comms: {{ player_ship.systems.comms if player_ship else 7 }},
        computers: {{ player_ship.systems.computers if player_ship else 7 }},
        engines: {{ player_ship.systems.engines if player_ship else 7 }},
        sensors: {{ player_ship.systems.sensors if player_ship else 7 }},
        structure: {{ player_ship.systems.structure if player_ship else 7 }},
        weapons: {{ player_ship.systems.weapons if player_ship else 7 }}
    };
    const shipDepts = {
        command: {{ player_ship.departments.command if player_ship else 2 }},
        conn: {{ player_ship.departments.conn if player_ship else 2 }},
        engineering: {{ player_ship.departments.engineering if player_ship else 2 }},
        medicine: {{ player_ship.departments.medicine if player_ship else 2 }},
        science: {{ player_ship.departments.science if player_ship else 2 }},
        security: {{ player_ship.departments.security if player_ship else 2 }}
    };

    // Current action config (for task roll actions)
    let currentActionConfig = null;

    let currentAction = null;
    let activeMinorAction = null;
    let selectedMajorAction = null;
    let selectedMinorAction = null;

    // Update turn counter display for both sides
    function updateTurnCounters(playerUsed, playerTotal, enemyUsed, enemyTotal) {
        document.getElementById('player-turns-used').textContent = playerUsed || 0;
        document.getElementById('player-turns-total').textContent = playerTotal || 0;
        document.getElementById('enemy-turns-used').textContent = enemyUsed || 0;
        document.getElementById('enemy-turns-total').textContent = enemyTotal || 0;
    }

    // Calculate momentum cost for bonus dice (escalating: 1st=1, 2nd=2, 3rd=3)
    function getBonusDiceCost(numDice) {
        // Cost: 1 die = 1, 2 dice = 1+2=3, 3 dice = 1+2+3=6
        if (numDice <= 0) return 0;
        if (numDice === 1) return 1;
        if (numDice === 2) return 3;
        return 6; // 3 dice
    }

    // Calculate max bonus dice affordable with given momentum
    function getMaxBonusDice(momentum) {
        if (momentum >= 6) return 3;
        if (momentum >= 3) return 2;
        if (momentum >= 1) return 1;
        return 0;
    }

    // Update bonus dice sections based on available momentum
    // STA 2e escalating cost: 1st die = 1 momentum, 2nd = 2, 3rd = 3
    function updateBonusDiceFromMomentum() {
        const currentMomentum = parseInt(document.getElementById('momentum').textContent) || 0;
        const maxBonusDice = getMaxBonusDice(currentMomentum);

        // List of all bonus dice sections and their inputs
        const bonusSections = [
            { sectionId: 'fire-bonus-section', inputId: 'fire-bonus' },
            { sectionId: 'ram-bonus-section', inputId: 'ram-bonus' },
            { sectionId: 'roll-bonus-section', inputId: 'roll-bonus' }
        ];

        bonusSections.forEach(({ sectionId, inputId }) => {
            const section = document.getElementById(sectionId);
            const input = document.getElementById(inputId);

            if (section && input) {
                if (currentMomentum > 0) {
                    // Show the section and set appropriate max
                    section.style.display = 'block';
                    input.max = maxBonusDice;

                    // If current value exceeds new max, reset it
                    const currentValue = parseInt(input.value) || 0;
                    if (currentValue > maxBonusDice) {
                        input.value = maxBonusDice;
                    }
                } else {
                    // No momentum - hide the section and reset value
                    section.style.display = 'none';
                    input.value = 0;
                    input.max = 0;
                }
            }
        });
    }

    // Update turn display
    function updateTurnDisplay(newTurn, newRound, data) {
        currentTurn = newTurn;
        const banner = document.getElementById('turn-banner');
        const actionsContainer = document.getElementById('actions-container');
        const endTurnSection = document.getElementById('end-turn-section');

        if (newTurn === 'player') {
            banner.className = 'turn-banner your-turn';
            banner.querySelector('.turn-text').textContent = 'YOUR TURN - Take one action';
            actionsContainer.style.display = 'block';
            endTurnSection.style.display = 'block';
        } else {
            banner.className = 'turn-banner enemy-turn';
            banner.querySelector('.turn-text').textContent = 'ENEMY TURN - Waiting for Game Master...';
            actionsContainer.style.display = 'none';
            endTurnSection.style.display = 'none';

            // Also hide all action panels (they're outside actions-container)
            document.getElementById('fire-panel').style.display = 'none';
            document.getElementById('defensive-fire-panel').style.display = 'none';
            document.getElementById('reroute-power-panel').style.display = 'none';
            document.getElementById('damage-control-panel').style.display = 'none';
            document.getElementById('ram-panel').style.display = 'none';
            document.getElementById('dice-panel').style.display = 'none';
        }

        // Update round in header
        document.querySelector('header h1').textContent = `{{ encounter.name }} - Round ${newRound}`;

        // Update turn counters if data is provided
        if (data) {
            updateTurnCounters(
                data.player_turns_used, data.player_turns_total,
                data.enemy_turns_used, data.enemy_turns_total
            );
        }
    }

    // Add turn-over indicator to a results element
    function addTurnOverIndicator(elementId, newTurn, turnData = null) {
        const element = document.getElementById(elementId);
        if (!element) return;

        // Remove any existing turn-over indicator
        const existing = element.querySelector('.turn-over-indicator');
        if (existing) existing.remove();

        // Add new indicator
        const indicator = document.createElement('div');
        indicator.className = 'turn-over-indicator';
        indicator.style.cssText = 'margin-top: 15px; padding: 12px; border-radius: 5px; text-align: center; font-weight: bold;';

        if (newTurn === 'enemy') {
            indicator.style.background = 'linear-gradient(135deg, #2a1a1a 0%, #3a2020 100%)';
            indicator.style.border = '2px solid var(--lcars-red)';
            indicator.innerHTML = `
                <div style="color: var(--lcars-red); font-size: 1.1em;">ACTION COMPLETE</div>
                <div style="color: var(--lcars-tan); margin-top: 5px;">Enemy Turn - Waiting for GM...</div>
            `;
        } else {
            // Check if enemy is out of turns (player gets consecutive turns)
            const enemyOutOfTurns = turnData && turnData.enemy_turns_used >= turnData.enemy_turns_total;
            const playerTurnsRemaining = turnData ? (turnData.player_turns_total - turnData.player_turns_used) : null;

            indicator.style.background = 'linear-gradient(135deg, #1a2a1a 0%, #203a20 100%)';
            indicator.style.border = '2px solid var(--lcars-green)';

            if (enemyOutOfTurns && playerTurnsRemaining > 0) {
                indicator.innerHTML = `
                    <div style="color: var(--lcars-green); font-size: 1.1em;">ACTION COMPLETE - CONTINUE!</div>
                    <div style="color: var(--lcars-tan); margin-top: 5px;">Enemy out of turns - You have ${playerTurnsRemaining} turn(s) remaining</div>
                `;
            } else {
                indicator.innerHTML = `
                    <div style="color: var(--lcars-green); font-size: 1.1em;">YOUR TURN</div>
                    <div style="color: var(--lcars-tan); margin-top: 5px;">Select your next action</div>
                `;
            }
        }

        element.appendChild(indicator);
    }

    // Fetch initial turn status on page load
    async function fetchTurnStatus() {
        try {
            const response = await fetch(`/api/encounter/${encounterId}/status`);
            if (response.ok) {
                const data = await response.json();
                updateTurnCounters(
                    data.player_turns_used, data.player_turns_total,
                    data.enemy_turns_used, data.enemy_turns_total
                );
            }
        } catch (e) {
            console.error('Failed to fetch turn status:', e);
        }
    }

    // Store action availability state
    let actionAvailability = {};

    // Fetch and update action availability based on breach status
    async function fetchActionAvailability() {
        try {
            const response = await fetch(`/api/encounter/${encounterId}/action-availability`);
            if (response.ok) {
                actionAvailability = await response.json();
                updateActionAvailabilityUI();
            }
        } catch (e) {
            console.error('Failed to fetch action availability:', e);
        }
    }

    // Update the UI to show which actions are available/disabled
    function updateActionAvailabilityUI() {
        // Find all action list items with data-action-name
        const actionItems = document.querySelectorAll('[data-action-name]');

        actionItems.forEach(item => {
            const actionName = item.getAttribute('data-action-name');
            const availability = actionAvailability[actionName];

            if (!availability) return;

            const breachWarning = item.querySelector('.breach-warning');
            const difficultyDisplay = item.querySelector('.difficulty-display');
            const baseDifficulty = parseInt(item.getAttribute('data-base-difficulty')) || 0;

            if (!availability.available) {
                // System destroyed - disable the action
                item.classList.add('action-disabled');
                if (breachWarning) {
                    breachWarning.textContent = `[${availability.reason}]`;
                    breachWarning.style.display = 'inline';
                }
            } else {
                // Action available
                item.classList.remove('action-disabled');
                if (breachWarning) {
                    breachWarning.style.display = 'none';
                }

                // Show breach modifier if any
                if (availability.breach_modifier > 0 && difficultyDisplay) {
                    const newDifficulty = baseDifficulty + availability.breach_modifier;
                    difficultyDisplay.innerHTML = `(Diff <span class="breach-modifier">${newDifficulty}</span> <span style="font-size:0.8em;">+${availability.breach_modifier} breach</span>)`;
                } else if (difficultyDisplay && baseDifficulty > 0) {
                    difficultyDisplay.textContent = `(Diff ${baseDifficulty})`;
                }
            }
        });
    }

    // Check if an action is available (for use in selectAction)
    function isActionAvailable(actionName) {
        const availability = actionAvailability[actionName];
        if (!availability) return { available: true, reason: null };
        return availability;
    }

    // Initialize on page load
    document.addEventListener('DOMContentLoaded', function() {
        fetchTurnStatus();
        fetchActionAvailability();
        updateBonusDiceFromMomentum();
    });

    // Show a brief result message for minor actions that don't need dice
    function showMinorActionResult(message) {
        const toast = document.createElement('div');
        toast.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 25px;
            background: #1a3a1a;
            border: 2px solid var(--lcars-green);
            border-radius: 5px;
            color: var(--lcars-green);
            font-weight: bold;
            z-index: 1000;
            animation: fadeIn 0.3s ease-in;
        `;
        toast.textContent = `OK ${message}`;
        document.body.appendChild(toast);
        setTimeout(() => {
            toast.style.animation = 'fadeOut 0.3s ease-out';
            setTimeout(() => toast.remove(), 300);
        }, 2000);
    }

    // Show an error toast notification
    function showErrorToast(message) {
        const toast = document.createElement('div');
        toast.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 25px;
            background: #3a1a1a;
            border: 2px solid var(--lcars-red);
            border-radius: 5px;
            color: var(--lcars-red);
            font-weight: bold;
            z-index: 1000;
            animation: fadeIn 0.3s ease-in;
        `;
        toast.textContent = `ERROR: ${message}`;
        document.body.appendChild(toast);
        setTimeout(() => {
            toast.style.animation = 'fadeOut 0.3s ease-out';
            setTimeout(() => toast.remove(), 300);
        }, 3000);
    }

    // Show a success toast notification
    function showSuccessToast(message) {
        const toast = document.createElement('div');
        toast.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 25px;
            background: #1a3a1a;
            border: 2px solid var(--lcars-green);
            border-radius: 5px;
            color: var(--lcars-green);
            font-weight: bold;
            z-index: 1000;
            animation: fadeIn 0.3s ease-in;
        `;
        toast.textContent = ` ${message}`;
        document.body.appendChild(toast);
        setTimeout(() => {
            toast.style.animation = 'fadeOut 0.3s ease-out';
            setTimeout(() => toast.remove(), 300);
        }, 2000);
    }

    // Minor action effect descriptions for display
    const MINOR_ACTION_EFFECTS = {
        'Calibrate Weapons': ['+1 damage on next attack'],
        'Targeting Solution': ['Re-roll 1d20 OR choose system on breach (pick one!)'],
        'Calibrate Sensors': ['Re-roll 1d20 on next sensor task'],
    };

    // Helper to clear all action selections visually
    function clearActionSelections(type) {
        const panels = document.querySelectorAll('.panel');
        panels.forEach(panel => {
            const h2 = panel.querySelector('h2');
            if (h2) {
                if (type === 'minor' && h2.textContent === 'Minor Actions') {
                    panel.querySelectorAll('.action-list li').forEach(li => {
                        li.classList.remove('action-selected');
                    });
                } else if (type === 'major' && h2.textContent === 'Major Actions') {
                    panel.querySelectorAll('.action-list li').forEach(li => {
                        li.classList.remove('action-selected');
                    });
                }
            }
        });
    }

    // Highlight selected action
    function highlightAction(actionName, type) {
        clearActionSelections(type);

        const panels = document.querySelectorAll('.panel');
        panels.forEach(panel => {
            const h2 = panel.querySelector('h2');
            if (h2) {
                const panelType = h2.textContent.includes('Minor') ? 'minor' :
                                  h2.textContent.includes('Major') ? 'major' : null;
                if (panelType === type) {
                    panel.querySelectorAll('.action-list li').forEach(li => {
                        const strongEl = li.querySelector('strong');
                        if (strongEl && strongEl.textContent === actionName) {
                            li.classList.add('action-selected');
                        }
                    });
                }
            }
        });
    }

    async function nextTurn() {
        const response = await fetch(`/api/encounter/${encounterId}/next-turn`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'}
        });
        const data = await response.json();

        updateTurnDisplay(data.current_turn, data.round, data);

        // Clear active minor action when turn ends
        activeMinorAction = null;
        selectedMajorAction = null;
        updateFireMinorActionBanner();
        updateMajorActionHighlights();
        updateSelectionSummary();

        // Clear all action highlights
        clearActionSelections('minor');
        clearActionSelections('major');

        // Hide all panels for new turn
        document.getElementById('fire-panel').style.display = 'none';
        document.getElementById('fire-results').style.display = 'none';
        document.getElementById('dice-panel').style.display = 'none';
        document.getElementById('dice-results').style.display = 'none';
        document.getElementById('selection-summary').style.display = 'none';
    }

    // List of buff actions that execute immediately (no roll required)
    const BUFF_ACTIONS = ['Calibrate Weapons', 'Calibrate Sensors', 'Targeting Solution'];

    // Major buff actions that execute immediately AND end the turn
    const MAJOR_BUFF_ACTIONS = ['Attack Pattern', 'Evasive Action'];

    // Minor actions that only work with Fire
    const FIRE_ONLY_MINOR_ACTIONS = ['Targeting Solution', 'Calibrate Weapons'];

    async function selectAction(name, type, difficulty) {
        if (currentTurn !== 'player') {
            showErrorToast("It's not your turn!");
            return;
        }

        // Check if action is available (system not destroyed)
        const availability = isActionAvailable(name);
        if (!availability.available) {
            showErrorToast(`Cannot use ${name}: ${availability.reason}`);
            return;
        }

        // Apply breach modifier to difficulty if applicable
        if (availability.breach_modifier > 0) {
            difficulty = difficulty + availability.breach_modifier;
        }

        currentAction = {name, type, difficulty};

        if (type === 'minor') {
            if (BUFF_ACTIONS.includes(name)) {
                executeBuffAction(name);
                highlightAction(name, 'minor');
            }
            return;
        }

        // Major action selected
        selectedMajorAction = name;
        highlightAction(name, 'major');
        updateSelectionSummary();

        if (name === 'Fire') {
            if (!weaponsArmed) {
                showErrorToast("Weapons are not armed! Use Arm Weapons first.");
                return;
            }
            document.getElementById('fire-panel').style.display = 'block';
            document.getElementById('defensive-fire-panel').style.display = 'none';
            document.getElementById('reroute-power-panel').style.display = 'none';
            document.getElementById('damage-control-panel').style.display = 'none';
            document.getElementById('ram-panel').style.display = 'none';
            document.getElementById('dice-panel').style.display = 'none';
            document.getElementById('fire-results').style.display = 'none';
            updateFireDetails();
            updateFireMinorActionBanner();
            document.getElementById('fire-panel').scrollIntoView({behavior: 'smooth'});
        } else if (name === 'Defensive Fire') {
            // Check momentum - need at least 2 for counterattack
            const currentMomentum = parseInt(document.getElementById('momentum').textContent) || 0;
            if (currentMomentum < 2) {
                showErrorToast("Defensive Fire requires at least 2 Momentum for counterattack!");
                return;
            }
            // Check for Evasive Action conflict (handled server-side, but we can warn)
            document.getElementById('fire-panel').style.display = 'none';
            document.getElementById('defensive-fire-panel').style.display = 'block';
            document.getElementById('reroute-power-panel').style.display = 'none';
            document.getElementById('damage-control-panel').style.display = 'none';
            document.getElementById('ram-panel').style.display = 'none';
            document.getElementById('dice-panel').style.display = 'none';
            document.getElementById('defensive-fire-results').style.display = 'none';

            // Update momentum warning in the panel
            updateDefensiveFireMomentumWarning();

            document.getElementById('defensive-fire-panel').scrollIntoView({behavior: 'smooth'});
        } else if (name === 'Reroute Power') {
            // Check Reserve Power
            if (!hasReservePower) {
                showErrorToast("Reroute Power requires Reserve Power!");
                return;
            }
            document.getElementById('fire-panel').style.display = 'none';
            document.getElementById('defensive-fire-panel').style.display = 'none';
            document.getElementById('reroute-power-panel').style.display = 'block';
            document.getElementById('damage-control-panel').style.display = 'none';
            document.getElementById('ram-panel').style.display = 'none';
            document.getElementById('dice-panel').style.display = 'none';
            document.getElementById('reroute-power-results').style.display = 'none';

            // Update the target display based on current selection
            updateRerouteTargetDisplay();

            document.getElementById('reroute-power-panel').scrollIntoView({behavior: 'smooth'});
        } else if (name === 'Ram') {
            document.getElementById('fire-panel').style.display = 'none';
            document.getElementById('defensive-fire-panel').style.display = 'none';
            document.getElementById('reroute-power-panel').style.display = 'none';
            document.getElementById('damage-control-panel').style.display = 'none';
            document.getElementById('ram-panel').style.display = 'block';
            document.getElementById('dice-panel').style.display = 'none';
            document.getElementById('ram-results').style.display = 'none';

            // Update damage display based on selected target
            updateRamDamageDisplay();

            document.getElementById('ram-panel').scrollIntoView({behavior: 'smooth'});
        } else if (name === 'Damage Control') {
            document.getElementById('fire-panel').style.display = 'none';
            document.getElementById('defensive-fire-panel').style.display = 'none';
            document.getElementById('reroute-power-panel').style.display = 'none';
            document.getElementById('ram-panel').style.display = 'none';
            document.getElementById('dice-panel').style.display = 'none';
            document.getElementById('damage-control-panel').style.display = 'block';
            document.getElementById('damage-control-results').style.display = 'none';

            // Populate breach options and update display
            populateDamageControlOptions();

            document.getElementById('damage-control-panel').scrollIntoView({behavior: 'smooth'});
        } else if (MAJOR_BUFF_ACTIONS.includes(name)) {
            // Major buff actions execute immediately and end turn
            executeMajorBuffAction(name);
            return;
        } else {
            try {
                const configResponse = await fetch(`/api/action-config/${encodeURIComponent(name)}`);
                const config = await configResponse.json();
                currentActionConfig = config;

                if (config.roll) {
                    const attrName = config.roll.attribute;
                    const discName = config.roll.discipline;
                    const attrValue = playerAttrs[attrName] || 9;
                    const discValue = playerDiscs[discName] || 2;
                    const targetNum = attrValue + discValue;

                    document.getElementById('roll-attr-name').textContent = attrName.charAt(0).toUpperCase() + attrName.slice(1);
                    document.getElementById('roll-attr-value').textContent = attrValue;
                    document.getElementById('roll-disc-name').textContent = discName.charAt(0).toUpperCase() + discName.slice(1);
                    document.getElementById('roll-disc-value').textContent = discValue;
                    document.getElementById('roll-target').textContent = targetNum;
                    document.getElementById('roll-diff-display').textContent = config.roll.difficulty;

                    document.getElementById('roll-attr').value = attrValue;
                    document.getElementById('roll-disc').value = discValue;
                    document.getElementById('roll-diff').value = config.roll.difficulty;

                    const assistRow = document.getElementById('ship-assist-row');
                    if (config.roll.ship_assist_system && config.roll.ship_assist_department) {
                        const sysName = config.roll.ship_assist_system;
                        const deptName = config.roll.ship_assist_department;
                        const sysValue = shipSystems[sysName] || 7;
                        const deptValue = shipDepts[deptName] || 2;
                        const assistTarget = sysValue + deptValue;

                        document.getElementById('ship-assist-system-name').textContent = sysName.charAt(0).toUpperCase() + sysName.slice(1);
                        document.getElementById('ship-assist-system-value').textContent = sysValue;
                        document.getElementById('ship-assist-dept-name').textContent = deptName.charAt(0).toUpperCase() + deptName.slice(1);
                        document.getElementById('ship-assist-dept-value').textContent = deptValue;
                        document.getElementById('ship-assist-target').textContent = assistTarget;
                        assistRow.style.display = 'block';
                    } else {
                        assistRow.style.display = 'none';
                    }
                }
            } catch (err) {
                console.error('Failed to fetch action config:', err);
                document.getElementById('roll-diff').value = difficulty;
                document.getElementById('roll-diff-display').textContent = difficulty;
            }

            document.getElementById('fire-panel').style.display = 'none';
            document.getElementById('damage-control-panel').style.display = 'none';
            document.getElementById('dice-panel').style.display = 'block';
            document.getElementById('current-action-display').style.display = 'block';
            document.getElementById('current-action-name').textContent = name;
            document.getElementById('dice-panel').scrollIntoView({behavior: 'smooth'});
        }
    }

    function updateFireMinorActionBanner() {
        const banner = document.getElementById('fire-minor-action-banner');
        const nameSpan = document.getElementById('fire-minor-action-name');
        const effectsDiv = document.getElementById('fire-minor-action-effects');
        const targetingSolutionPanel = document.getElementById('targeting-solution-panel');

        if (activeMinorAction) {
            banner.style.display = 'block';
            nameSpan.textContent = activeMinorAction;
            const effects = MINOR_ACTION_EFFECTS[activeMinorAction] || [];
            effectsDiv.innerHTML = effects.map(e => `* ${e}`).join('<br>');

            if (activeMinorAction === 'Targeting Solution') {
                targetingSolutionPanel.style.display = 'block';
            } else {
                targetingSolutionPanel.style.display = 'none';
            }
        } else {
            banner.style.display = 'none';
            targetingSolutionPanel.style.display = 'none';
        }
    }

    function updateMajorActionHighlights() {
        const fireAction = document.querySelector('.fire-action');
        if (fireAction) {
            if (activeMinorAction && FIRE_ONLY_MINOR_ACTIONS.includes(activeMinorAction)) {
                fireAction.classList.add('fire-action-highlighted');
            } else {
                fireAction.classList.remove('fire-action-highlighted');
            }
        }
    }

    function updateDefensiveFireMomentumWarning() {
        const warningDiv = document.getElementById('defensive-fire-momentum-warning');
        const momentumSpan = document.getElementById('df-current-momentum');
        const currentMomentum = parseInt(document.getElementById('momentum').textContent) || 0;

        // Show warning if momentum is exactly 2 (will be 0 after counterattack) or less
        // Note: We already block selection if < 2, but show warning if exactly 2
        if (currentMomentum <= 3) {
            warningDiv.style.display = 'block';
            momentumSpan.textContent = currentMomentum;
        } else {
            warningDiv.style.display = 'none';
        }
    }

    function updateSelectionSummary() {
        const summaryPanel = document.getElementById('selection-summary');
        const summaryMinor = document.getElementById('summary-minor');
        const summaryMajor = document.getElementById('summary-major');

        if (activeMinorAction || selectedMajorAction) {
            summaryPanel.style.display = 'block';
        } else {
            summaryPanel.style.display = 'none';
        }

        if (activeMinorAction) {
            const effects = MINOR_ACTION_EFFECTS[activeMinorAction] || [];
            summaryMinor.innerHTML = `
                <strong style="color: var(--lcars-green);">OK ${activeMinorAction}</strong>
                <div style="font-size: 0.85em; color: var(--lcars-tan); margin-top: 4px;">
                    ${effects.map(e => `* ${e}`).join('<br>')}
                </div>
            `;
        } else {
            summaryMinor.innerHTML = '<span style="color: #666;">None selected (optional)</span>';
        }

        if (selectedMajorAction) {
            summaryMajor.innerHTML = `<strong style="color: var(--lcars-green);">OK ${selectedMajorAction}</strong>`;
        } else {
            summaryMajor.innerHTML = '<span style="color: #888;">Select a major action to proceed</span>';
        }
    }

    function cancelAction() {
        currentAction = null;
        selectedMajorAction = null;

        clearActionSelections('major');
        updateSelectionSummary();

        document.getElementById('fire-panel').style.display = 'none';
        document.getElementById('defensive-fire-panel').style.display = 'none';
        document.getElementById('reroute-power-panel').style.display = 'none';
        document.getElementById('damage-control-panel').style.display = 'none';
        document.getElementById('ram-panel').style.display = 'none';
        document.getElementById('dice-panel').style.display = 'none';
        document.getElementById('current-action-display').style.display = 'none';
    }

    // Reroute Power functions
    function updateRerouteTargetDisplay() {
        const select = document.getElementById('reroute-system-select');
        const display = document.getElementById('reroute-target-display');
        display.textContent = select.value.toUpperCase();
    }

    // Add event listener for the system select dropdown
    document.addEventListener('DOMContentLoaded', function() {
        const rerouteSelect = document.getElementById('reroute-system-select');
        if (rerouteSelect) {
            rerouteSelect.addEventListener('change', updateRerouteTargetDisplay);
        }
    });

    // ===== DAMAGE CONTROL FUNCTIONS =====

    let damageControlTargetSystem = null;

    function populateDamageControlOptions() {
        const select = document.getElementById('damage-control-system-select');
        const noBreachWarning = document.getElementById('damage-control-no-breach-warning');
        const systemSection = document.getElementById('damage-control-system-section');

        // Find all systems with breaches from the DOM
        const breachedSystems = [];
        document.querySelectorAll('.stat-row.breached').forEach(row => {
            const system = row.getAttribute('data-system');
            const breachCount = row.querySelector('.breach-count');
            const potency = breachCount ? parseInt(breachCount.textContent) || 1 : 1;
            if (system) {
                breachedSystems.push({ system, potency });
            }
        });

        // Clear and populate the select
        select.innerHTML = '';

        if (breachedSystems.length === 0) {
            noBreachWarning.style.display = 'block';
            systemSection.style.display = 'none';
            damageControlTargetSystem = null;
            return;
        }

        noBreachWarning.style.display = 'none';
        systemSection.style.display = 'block';

        breachedSystems.forEach(({ system, potency }) => {
            const option = document.createElement('option');
            option.value = system;
            option.textContent = `${system.toUpperCase()} - Breach Potency ${potency}`;
            option.dataset.potency = potency;
            select.appendChild(option);
        });

        damageControlTargetSystem = breachedSystems[0].system;
        updateDamageControlDisplay();
    }

    function updateDamageControlDisplay() {
        const select = document.getElementById('damage-control-system-select');
        const selectedOption = select.options[select.selectedIndex];
        const potency = selectedOption ? parseInt(selectedOption.dataset.potency) || 0 : 0;

        document.getElementById('damage-control-breach-potency').textContent = potency;
        document.getElementById('damage-control-total-difficulty').textContent = 2 + potency;

        damageControlTargetSystem = select.value;

        // Update bonus dice availability based on momentum
        const currentMomentum = parseInt(document.getElementById('momentum').textContent) || 0;
        const bonusSection = document.getElementById('damage-control-bonus-section');
        const bonusInput = document.getElementById('damage-control-bonus');

        if (currentMomentum > 0) {
            bonusSection.style.display = 'block';
            bonusInput.max = Math.min(3, currentMomentum); // Max 3 dice
            bonusInput.value = Math.min(bonusInput.value, bonusInput.max);
        } else {
            bonusSection.style.display = 'none';
            bonusInput.value = 0;
        }
    }

    async function executeDamageControlRoll() {
        if (!damageControlTargetSystem) {
            showErrorToast("No breach selected to repair!");
            return;
        }

        const select = document.getElementById('damage-control-system-select');
        const selectedOption = select.options[select.selectedIndex];
        const breachPotency = selectedOption ? parseInt(selectedOption.dataset.potency) || 0 : 0;
        const difficulty = 2 + breachPotency;
        const focus = document.getElementById('damage-control-focus').checked;
        const bonus = parseInt(document.getElementById('damage-control-bonus').value) || 0;
        const resultsDiv = document.getElementById('damage-control-results');

        // Use character's Presence + Engineering
        const attr = playerAttrs.presence || 9;
        const disc = playerDiscs.engineering || 3;

        try {
            // First, do the roll
            const rollResponse = await fetch('/api/roll', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    attribute: attr,
                    discipline: disc,
                    difficulty: difficulty,
                    focus: focus,
                    bonus_dice: bonus
                })
            });
            const rollData = await rollResponse.json();

            // Show roll results
            resultsDiv.style.display = 'block';
            const diceHtml = rollData.rolls.map(roll => {
                let cls = 'dice-fail';
                if (roll === 1) cls = 'dice-crit';
                else if (focus && roll <= disc) cls = 'dice-crit';
                else if (roll <= attr + disc) cls = 'dice-success';
                else if (roll === 20) cls = 'dice-complication';
                return `<span class="dice-result ${cls}">${roll}</span>`;
            }).join('');

            if (rollData.succeeded) {
                // Execute the action with target_system
                const execResponse = await fetch(`/api/encounter/${encounterId}/execute-action`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        action_name: 'Damage Control',
                        roll_succeeded: true,
                        roll_momentum: rollData.momentum_generated,
                        target_system: damageControlTargetSystem,
                        bonus_dice: bonus,
                        character_id: playerCharId
                    })
                });
                const execData = await execResponse.json();

                // Check for API error
                if (execData.error) {
                    console.error('Damage Control API error:', execData.error);
                    showErrorToast(execData.error);
                    return;
                }

                // Update momentum
                if (execData.new_momentum !== undefined) {
                    document.getElementById('momentum').textContent = execData.new_momentum;
                }

                // Update the breach display in the UI
                if (execData.system_patched) {
                    const systemRow = document.querySelector(`.stat-row[data-system="${execData.system_patched}"]`);
                    if (systemRow) {
                        const breachIndicator = systemRow.querySelector('.breach-indicator');
                        const breachCount = systemRow.querySelector('.breach-count');

                        if (execData.remaining_breach_potency <= 0) {
                            // Breach fully repaired
                            systemRow.classList.remove('breached');
                            if (breachIndicator) breachIndicator.style.display = 'none';
                        } else if (breachCount) {
                            // Reduced potency
                            breachCount.textContent = execData.remaining_breach_potency;
                        }
                    }
                }

                resultsDiv.innerHTML = `
                    <div style="padding: 15px; background: #1a3a1a; border: 2px solid var(--lcars-green); border-radius: 5px;">
                        <strong style="color: var(--lcars-green);">SUCCESS!</strong>
                        <div style="margin: 10px 0;">${diceHtml}</div>
                        <p>${rollData.successes} successes vs Difficulty ${difficulty}</p>
                        <p style="margin-top: 10px; color: var(--lcars-green);">${execData.message}</p>
                        ${rollData.momentum_generated > 0 ? `<p style="color: var(--lcars-blue);">+${rollData.momentum_generated} Momentum</p>` : ''}
                    </div>
                `;

                showSuccessToast(`Repaired ${damageControlTargetSystem.toUpperCase()} breach!`);

                // Update turn display - backend already alternated turn
                if (execData.current_turn) {
                    currentTurn = execData.current_turn;
                    updateTurnDisplay(execData.current_turn, execData.round, execData);

                    // Clear action state
                    activeMinorAction = null;
                    selectedMajorAction = null;
                    updateFireMinorActionBanner();
                    updateMajorActionHighlights();
                    clearActionSelections('minor');
                    clearActionSelections('major');

                    // Add turn indicator to results (keep panel visible)
                    addTurnOverIndicator('damage-control-results', execData.current_turn, execData);
                }

                // Update turn counters
                if (execData.player_turns_used !== undefined) {
                    updateTurnCounters(
                        execData.player_turns_used, execData.player_turns_total,
                        execData.enemy_turns_used, execData.enemy_turns_total
                    );
                }
            } else {
                resultsDiv.innerHTML = `
                    <div style="padding: 15px; background: #3a1a1a; border: 2px solid var(--lcars-red); border-radius: 5px;">
                        <strong style="color: var(--lcars-red);">FAILED!</strong>
                        <div style="margin: 10px 0;">${diceHtml}</div>
                        <p>${rollData.successes} successes vs Difficulty ${difficulty}</p>
                        ${rollData.complications > 0 ? `<p style="color: var(--lcars-red);">${rollData.complications} complication(s)!</p>` : ''}
                    </div>
                `;

                showErrorToast("Damage Control failed!");

                // Failed roll still consumes the major action - call execute-action to log and end turn
                try {
                    const failResponse = await fetch(`/api/encounter/${encounterId}/execute-action`, {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({
                            action_name: 'Damage Control',
                            roll_succeeded: false,
                            roll_successes: rollData.successes,
                            roll_complications: rollData.complications,
                            roll_dice: rollData.rolls,
                            roll_target: attr + disc,
                            target_system: damageControlTargetSystem,
                            bonus_dice: bonus,
                            character_id: playerCharId
                        })
                    });
                    const failData = await failResponse.json();

                    // Update turn display
                    if (failData.current_turn) {
                        currentTurn = failData.current_turn;
                        updateTurnDisplay(failData.current_turn, failData.round, failData);

                        // Clear action state
                        activeMinorAction = null;
                        selectedMajorAction = null;
                        updateFireMinorActionBanner();
                        updateMajorActionHighlights();
                        clearActionSelections('minor');
                        clearActionSelections('major');

                        // Add turn indicator to results (keep panel visible)
                        addTurnOverIndicator('damage-control-results', failData.current_turn, failData);
                    }

                    if (failData.player_turns_used !== undefined) {
                        updateTurnCounters(
                            failData.player_turns_used, failData.player_turns_total,
                            failData.enemy_turns_used, failData.enemy_turns_total
                        );
                    }
                } catch (e) {
                    console.error('Failed to record failed action:', e);
                }
            }
        } catch (err) {
            resultsDiv.style.display = 'block';
            resultsDiv.innerHTML = `
                <div style="padding: 15px; background: #3a1a1a; border: 2px solid var(--lcars-red); border-radius: 5px;">
                    <strong style="color: var(--lcars-red);">ERROR:</strong> ${err.message}
                </div>
            `;
        }
    }

    // ===== END DAMAGE CONTROL FUNCTIONS =====

    async function executeReroutePower() {
        const targetSystem = document.getElementById('reroute-system-select').value;
        const resultsDiv = document.getElementById('reroute-power-results');

        try {
            const response = await fetch(`/api/encounter/${encounterId}/execute-action`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    action_name: 'Reroute Power',
                    target_system: targetSystem,
                    character_id: playerCharId
                })
            });
            const data = await response.json();

            resultsDiv.style.display = 'block';

            if (data.error) {
                resultsDiv.innerHTML = `
                    <div style="padding: 15px; background: #3a1a1a; border: 2px solid var(--lcars-red); border-radius: 5px;">
                        <strong style="color: var(--lcars-red);">ERROR:</strong> ${data.error}
                    </div>
                `;
                return;
            }

            if (data.success) {
                // Update local reserve power state
                hasReservePower = false;
                updateReservePowerDisplay();

                resultsDiv.innerHTML = `
                    <div style="padding: 15px; background: #1a3a1a; border: 2px solid var(--lcars-green); border-radius: 5px;">
                        <strong style="color: var(--lcars-green);">SUCCESS!</strong>
                        <p style="margin: 10px 0 0 0;">${data.message}</p>
                        <p style="margin: 10px 0 0 0; color: var(--lcars-orange);">Reserve Power consumed.</p>
                    </div>
                `;

                showSuccessToast(`Power rerouted to ${targetSystem.toUpperCase()}!`);

                // Handle turn changes (Reroute Power is a major action)
                if (data.turn_ended) {
                    currentTurn = 'enemy';
                    updateTurnDisplay();
                    showSuccessToast("Enemy turn!");
                }

                // Mark action as complete
                selectedMajorAction = 'Reroute Power';
                updateSelectionSummary();
            } else {
                resultsDiv.innerHTML = `
                    <div style="padding: 15px; background: #3a1a1a; border: 2px solid var(--lcars-red); border-radius: 5px;">
                        <strong style="color: var(--lcars-red);">FAILED:</strong> ${data.message}
                    </div>
                `;
            }

        } catch (err) {
            resultsDiv.innerHTML = `
                <div style="padding: 15px; background: #3a1a1a; border: 2px solid var(--lcars-red); border-radius: 5px;">
                    <strong style="color: var(--lcars-red);">ERROR:</strong> ${err.message}
                </div>
            `;
        }
    }

    function updateReservePowerDisplay() {
        // Update any reserve power indicators on the page
        const powerStatus = document.getElementById('reserve-power-status');
        if (powerStatus) {
            powerStatus.textContent = hasReservePower ? '[AVAILABLE]' : '[DEPLETED]';
            powerStatus.style.color = hasReservePower ? 'var(--lcars-green)' : 'var(--lcars-red)';

            // Update the container styling too
            const container = powerStatus.closest('.resource-pool');
            if (container) {
                container.style.background = hasReservePower ? '#1a3a1a' : '#3a1a1a';
                container.style.borderColor = hasReservePower ? 'var(--lcars-green)' : 'var(--lcars-red)';

                // Update the label color
                const label = container.querySelector('span:first-child');
                if (label) {
                    label.style.color = hasReservePower ? 'var(--lcars-green)' : 'var(--lcars-red)';
                }
            }
        }
    }

    // Ram action functions
    function updateRamDamageDisplay() {
        const select = document.getElementById('ram-target-select');
        const selectedOption = select.options[select.selectedIndex];
        const targetScale = parseInt(selectedOption.dataset.scale) || 3;

        document.getElementById('ram-their-damage').textContent = targetScale;
    }

    // Add event listener for the ram target select dropdown
    document.addEventListener('DOMContentLoaded', function() {
        const ramSelect = document.getElementById('ram-target-select');
        if (ramSelect) {
            ramSelect.addEventListener('change', updateRamDamageDisplay);
        }
    });

    async function executeRamAction() {
        const targetIndex = parseInt(document.getElementById('ram-target-select').value);
        const focus = document.getElementById('ram-focus').checked;
        const bonusDice = parseInt(document.getElementById('ram-bonus').value) || 0;
        const resultsDiv = document.getElementById('ram-results');

        try {
            const response = await fetch(`/api/encounter/${encounterId}/ram`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    target_index: targetIndex,
                    attribute: playerAttrs.daring || 9,
                    discipline: playerDiscs.conn || 3,
                    difficulty: 2,
                    focus: focus,
                    bonus_dice: bonusDice,
                    character_id: playerCharId
                })
            });
            const data = await response.json();

            resultsDiv.style.display = 'block';

            if (data.error) {
                resultsDiv.innerHTML = `
                    <div style="padding: 15px; background: #3a1a1a; border: 2px solid var(--lcars-red); border-radius: 5px;">
                        <strong style="color: var(--lcars-red);">ERROR:</strong> ${data.error}
                    </div>
                `;
                return;
            }

            // Build dice display
            let diceHtml = '<div style="display: flex; gap: 10px; flex-wrap: wrap; margin: 10px 0;">';
            const charDiceCount = data.rolls.length - 1; // Last die is ship assist
            for (let i = 0; i < data.rolls.length; i++) {
                const roll = data.rolls[i];
                const isShipDie = i === data.rolls.length - 1;
                let bgColor = '#333';
                let border = '2px solid #666';

                if (roll === 1) {
                    bgColor = '#1a4a1a';
                    border = '2px solid var(--lcars-green)';
                } else if (roll === 20) {
                    bgColor = '#4a1a1a';
                    border = '2px solid var(--lcars-red)';
                } else if (roll <= data.target_number || (isShipDie && roll <= data.ship_target_number)) {
                    bgColor = '#1a3a1a';
                    border = '2px solid var(--lcars-green)';
                }

                diceHtml += `
                    <div style="width: 50px; height: 50px; background: ${bgColor}; border: ${border};
                                border-radius: 5px; display: flex; align-items: center; justify-content: center;
                                font-size: 1.5em; font-weight: bold; ${isShipDie ? 'border-style: dashed;' : ''}">
                        ${roll}
                    </div>
                `;
            }
            diceHtml += '</div>';

            if (data.succeeded) {
                // Build damage summary for both ships
                let damageHtml = `
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 15px;">
                        <div style="padding: 10px; background: #1a3a1a; border: 2px solid var(--lcars-green); border-radius: 5px;">
                            <strong style="color: var(--lcars-green);">DAMAGE TO TARGET</strong>
                            <p>Collision Damage: ${data.target_collision_damage}</p>
                            <p>Shield Damage: ${data.target_shield_damage}</p>
                            <p>Hull Damage: ${data.target_hull_damage}</p>
                            ${data.target_breaches_caused > 0 ? `<p style="color: var(--lcars-orange);">Breaches: ${data.target_systems_hit.join(', ')}</p>` : ''}
                            <p>Shields Remaining: ${data.target_shields_remaining}</p>
                        </div>
                        <div style="padding: 10px; background: #3a2a1a; border: 2px solid var(--lcars-orange); border-radius: 5px;">
                            <strong style="color: var(--lcars-orange);">DAMAGE TO YOUR SHIP</strong>
                            <p>Collision Damage: ${data.player_collision_damage}</p>
                            <p>Shield Damage: ${data.player_shield_damage}</p>
                            <p>Hull Damage: ${data.player_hull_damage}</p>
                            ${data.player_breaches_caused > 0 ? `<p style="color: var(--lcars-red);">Breaches: ${data.player_systems_hit.join(', ')}</p>` : ''}
                            <p>Shields Remaining: ${data.player_shields_remaining}</p>
                        </div>
                    </div>
                `;

                resultsDiv.innerHTML = `
                    <div style="padding: 15px; background: #1a3a1a; border: 2px solid var(--lcars-green); border-radius: 5px;">
                        <strong style="color: var(--lcars-green);">COLLISION!</strong>
                        <p>${data.successes} successes vs difficulty ${data.difficulty}</p>
                        ${diceHtml}
                        ${damageHtml}
                        ${data.momentum_generated > 0 ? `<p style="margin-top: 10px; color: var(--lcars-blue);">+${data.momentum_generated} Momentum generated</p>` : ''}
                    </div>
                `;

                showSuccessToast('Ram successful! Both ships took collision damage.');

                // Update ship displays
                updatePlayerShipDisplay(data);
                if (typeof updateEnemyShipDisplay === 'function') {
                    updateEnemyShipDisplay(targetIndex, data);
                }

                // Refresh action availability after taking damage (breaches may have occurred)
                if (data.player_breaches_caused > 0) {
                    fetchActionAvailability();
                }

                // Update momentum
                if (data.new_momentum !== undefined) {
                    document.getElementById('momentum').textContent = data.new_momentum;
                    updateBonusDiceFromMomentum();
                }

            } else {
                resultsDiv.innerHTML = `
                    <div style="padding: 15px; background: #3a1a1a; border: 2px solid var(--lcars-red); border-radius: 5px;">
                        <strong style="color: var(--lcars-red);">MISSED!</strong>
                        <p>${data.successes} successes vs difficulty ${data.difficulty} - failed to connect!</p>
                        ${diceHtml}
                    </div>
                `;

                showErrorToast('Ram failed! Target evaded the collision.');
            }

            // Handle turn state from response
            if (data.current_turn) {
                updateTurnDisplay(data.current_turn, data.round, data);

                // Clear action state
                activeMinorAction = null;
                selectedMajorAction = null;
                updateFireMinorActionBanner();
                updateMajorActionHighlights();
                clearActionSelections('minor');
                clearActionSelections('major');

                // Add turn indicator to ram results
                addTurnOverIndicator('ram-results', data.current_turn, data);
            }

            if (data.player_turns_used !== undefined) {
                updateTurnCounters(
                    data.player_turns_used, data.player_turns_total,
                    data.enemy_turns_used, data.enemy_turns_total
                );
            }

        } catch (err) {
            resultsDiv.innerHTML = `
                <div style="padding: 15px; background: #3a1a1a; border: 2px solid var(--lcars-red); border-radius: 5px;">
                    <strong style="color: var(--lcars-red);">ERROR:</strong> ${err.message}
                </div>
            `;
        }
    }

    async function executeBuffAction(actionName) {
        const response = await fetch(`/api/encounter/${encounterId}/execute-action`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                action_name: actionName,
                character_id: playerCharId
            })
        });
        const data = await response.json();

        const resultsDiv = document.getElementById('dice-results');
        const displayDiv = document.getElementById('dice-display');
        resultsDiv.style.display = 'block';

        if (data.success) {
            activeMinorAction = actionName;
            updateMajorActionHighlights();
            updateSelectionSummary();
            document.getElementById('selection-summary').scrollIntoView({behavior: 'smooth'});
        } else {
            document.getElementById('dice-panel').style.display = 'block';
            resultsDiv.style.display = 'block';
            displayDiv.innerHTML = `
                <div class="alert alert-error" style="padding: 15px; background: #3a1a1a; border: 2px solid var(--lcars-red); border-radius: 5px;">
                    <strong>ERROR:</strong> ${data.error || 'Action failed'}
                </div>
            `;
        }
    }

    async function executeMajorBuffAction(actionName) {
        // Execute the buff action
        const response = await fetch(`/api/encounter/${encounterId}/execute-action`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                action_name: actionName,
                character_id: playerCharId
            })
        });
        const data = await response.json();

        if (data.success) {
            // Show results in dice panel
            const resultsDiv = document.getElementById('dice-results');
            const displayDiv = document.getElementById('dice-display');
            document.getElementById('dice-panel').style.display = 'block';
            resultsDiv.style.display = 'block';

            displayDiv.innerHTML = `
                <div class="alert alert-success" style="padding: 15px; background: #1a3a1a; border: 2px solid var(--lcars-green); border-radius: 5px;">
                    <strong style="color: var(--lcars-green);">${actionName.toUpperCase()} ACTIVATED!</strong>
                    <p style="margin-top: 10px;">${data.message || 'Effect applied successfully.'}</p>
                </div>
            `;

            // Update resistance display if applicable
            if (data.resistance_bonus) {
                currentResistanceBonus += data.resistance_bonus;
                updateResistanceDisplay();
            }

            // Handle turn state from response
            if (data.current_turn) {
                updateTurnDisplay(data.current_turn, data.round, data);

                // Clear action state
                activeMinorAction = null;
                selectedMajorAction = null;
                updateFireMinorActionBanner();
                updateMajorActionHighlights();
                clearActionSelections('minor');
                clearActionSelections('major');

                // Add turn indicator
                addTurnOverIndicator('dice-display', data.current_turn, data);
            }

            if (data.player_turns_used !== undefined) {
                updateTurnCounters(
                    data.player_turns_used, data.player_turns_total,
                    data.enemy_turns_used, data.enemy_turns_total
                );
            }
        } else {
            showErrorToast(data.error || `${actionName} failed!`);
        }
    }

    function updateFireDetails() {
        const weaponSelect = document.getElementById('weapon-select');
        const selectedOption = weaponSelect.options[weaponSelect.selectedIndex];
        const baseDamage = parseInt(selectedOption.dataset.damage);
        const weaponType = selectedOption.dataset.type;

        const totalDamage = baseDamage + weaponsBonus;
        const difficulty = weaponType === 'torpedo' ? 3 : 2;

        document.getElementById('fire-damage').textContent = totalDamage;
        document.getElementById('fire-difficulty').textContent = difficulty;
    }

    document.getElementById('weapon-select').addEventListener('change', updateFireDetails);

    const shipWeapons = {{ player_ship.systems.weapons if player_ship else 7 }};
    const shipSecurity = {{ player_ship.departments.security if player_ship else 2 }};
    const shipTargetNumber = shipWeapons + shipSecurity;

    let lastFireData = null;

    function getSystemFromRoll(roll) {
        if (roll === 1) return "comms";
        if (roll === 2) return "computers";
        if (roll <= 6) return "engines";
        if (roll <= 9) return "sensors";
        if (roll <= 17) return "structure";
        return "weapons";
    }

    function rollForBreach(breachIndex) {
        if (!window.pendingBreaches) return;

        const resultSpan = document.getElementById(`breach-result-${breachIndex}`);
        const system = window.pendingBreaches.systems[breachIndex];

        let rollCount = 0;
        const systems = ['COMMS', 'COMPUTERS', 'ENGINES', 'SENSORS', 'STRUCTURE', 'WEAPONS'];
        const rollInterval = setInterval(() => {
            const randomSys = systems[Math.floor(Math.random() * systems.length)];
            resultSpan.innerHTML = `<span style="color: var(--lcars-orange);">ROLLING: ${randomSys}...</span>`;
            rollCount++;

            if (rollCount >= 10) {
                clearInterval(rollInterval);
                const roll = Math.floor(Math.random() * 20) + 1;
                resultSpan.innerHTML = `
                    <span style="color: var(--lcars-tan);">Rolled ${roll} -> </span>
                    <span style="color: var(--lcars-red); font-weight: bold;">${system.toUpperCase()}</span>
                `;
                window.pendingBreaches.revealed.push(breachIndex);
            }
        }, 80);
    }

    async function chooseBreachSystem(breachIndex) {
        if (!window.pendingBreaches) return;

        const select = document.getElementById(`breach-choose-${breachIndex}`);
        const newSystem = select.value;
        const resultSpan = document.getElementById(`breach-result-${breachIndex}`);
        const targetIndex = window.pendingBreaches.targetIndex;

        const response = await fetch(`/api/encounter/${encounterId}/change-breach-system`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                target_index: targetIndex,
                breach_index: breachIndex,
                new_system: newSystem
            })
        });
        const data = await response.json();

        if (data.success) {
            resultSpan.innerHTML = `
                <span style="color: var(--lcars-green); font-weight: bold;">TARGET: ${newSystem.toUpperCase()}</span>
                <span style="color: var(--lcars-green);"> (TARGETED)</span>
            `;
            window.pendingBreaches.revealed.push(breachIndex);
            window.pendingBreaches.canChooseSystem = false;

            activeMinorAction = null;
            updateFireMinorActionBanner();
            updateMajorActionHighlights();
            updateSelectionSummary();
        } else {
            alert('Failed to choose breach system: ' + (data.error || 'Unknown error'));
        }
    }

    async function rerollDie(dieIndex) {
        if (!lastFireData) {
            alert('No previous roll to re-roll!');
            return;
        }

        const response = await fetch('/api/fire', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                ...lastFireData,
                reroll_die_index: dieIndex,
                previous_rolls: lastFireData.previous_rolls,
                character_id: playerCharId
            })
        });
        const data = await response.json();

        displayFireResults(data, lastFireData.targetIndex, lastFireData.focus, lastFireData.bonusDice, lastFireData.difficulty);
    }

    async function executeFireAction() {
        if (currentTurn !== 'player') {
            showErrorToast("It's not your turn!");
            return;
        }

        if (!weaponsArmed) {
            const resultsDiv = document.getElementById('fire-results');
            resultsDiv.style.display = 'block';
            resultsDiv.innerHTML = `
                <div class="alert alert-danger" style="padding: 15px; background: #3a1a1a; border: 2px solid var(--lcars-red); border-radius: 5px;">
                    <strong>ERROR: Weapons are not armed!</strong><br>
                    Use the <em>Arm Weapons</em> minor action first.
                </div>
            `;
            return;
        }

        const weaponSelect = document.getElementById('weapon-select');
        const targetSelect = document.getElementById('target-select');
        const selectedWeapon = weaponSelect.options[weaponSelect.selectedIndex];
        const targetIndex = parseInt(targetSelect.value);

        const baseDamage = parseInt(selectedWeapon.dataset.damage);
        const weaponType = selectedWeapon.dataset.type;
        const difficulty = weaponType === 'torpedo' ? 3 : 2;
        const focus = document.getElementById('fire-focus').checked;
        const bonusDice = parseInt(document.getElementById('fire-bonus').value) || 0;

        lastFireData = {
            encounter_id: encounterId,
            weapon_index: parseInt(weaponSelect.value),
            target_index: targetIndex,
            targetIndex: targetIndex,
            attribute: playerAttrs.control,
            discipline: playerDiscs.security,
            difficulty: difficulty,
            focus: focus,
            bonus_dice: bonusDice,
            bonusDice: bonusDice,
        };

        const response = await fetch('/api/fire', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                encounter_id: encounterId,
                weapon_index: parseInt(weaponSelect.value),
                target_index: targetIndex,
                attribute: playerAttrs.control,
                discipline: playerDiscs.security,
                difficulty: difficulty,
                focus: focus,
                bonus_dice: bonusDice,
                character_id: playerCharId
            })
        });
        const data = await response.json();

        lastFireData.previous_rolls = data.rolls;

        displayFireResults(data, targetIndex, focus, bonusDice, difficulty);

        // Debug: log turn state from fire response
        console.log('Fire response turn state:', {
            current_turn: data.current_turn,
            round: data.round,
            player_turns_used: data.player_turns_used,
            player_turns_total: data.player_turns_total,
            enemy_turns_used: data.enemy_turns_used,
            enemy_turns_total: data.enemy_turns_total,
            turn_ended: data.turn_ended
        });

        // Handle turn state from response
        if (data.current_turn) {
            updateTurnDisplay(data.current_turn, data.round, data);

            // Clear action state
            activeMinorAction = null;
            selectedMajorAction = null;
            updateFireMinorActionBanner();
            updateMajorActionHighlights();
            clearActionSelections('minor');
            clearActionSelections('major');

            // Add turn indicator to fire results
            addTurnOverIndicator('fire-results', data.current_turn, data);
        } else {
            console.warn('Fire response missing current_turn!', data);
        }

        if (data.player_turns_used !== undefined) {
            updateTurnCounters(
                data.player_turns_used, data.player_turns_total,
                data.enemy_turns_used, data.enemy_turns_total
            );
        }
    }

    async function executeDefensiveFire() {
        if (currentTurn !== 'player') {
            showErrorToast("It's not your turn!");
            return;
        }

        const weaponSelect = document.getElementById('defensive-fire-weapon-select');
        const weaponIndex = parseInt(weaponSelect.value);
        const weaponName = weaponSelect.options[weaponSelect.selectedIndex].text;

        const resultsDiv = document.getElementById('defensive-fire-results');

        try {
            const response = await fetch(`/api/encounter/${encounterId}/execute-action`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    action_name: 'Defensive Fire',
                    weapon_index: weaponIndex,
                    role: 'player',
                    character_id: playerCharId
                })
            });
            const data = await response.json();

            resultsDiv.style.display = 'block';

            if (data.success) {
                resultsDiv.innerHTML = `
                    <div class="alert alert-success" style="padding: 15px; background: #1a2a3a; border: 2px solid var(--lcars-purple); border-radius: 5px;">
                        <strong style="color: var(--lcars-purple);">DEFENSIVE FIRE ACTIVATED!</strong><br><br>
                        <div style="color: var(--lcars-tan);">
                            ${data.message}<br><br>
                            <strong>Weapon:</strong> ${data.weapon_name || weaponName}<br>
                            <strong>Duration:</strong> Until your next turn
                        </div>
                        <div style="margin-top: 10px; padding: 10px; background: #222; border-radius: 5px;">
                            <em style="color: var(--lcars-orange);">
                                When enemies attack, you will make an opposed roll.<br>
                                If you win, you may spend 2 Momentum to counterattack.
                            </em>
                        </div>
                    </div>
                `;
                showSuccessToast('Defensive Fire activated!');

                // Handle turn changes (Defensive Fire is a major action)
                if (data.turn_ended) {
                    currentTurn = 'enemy';
                    updateTurnDisplay();
                    showSuccessToast("Enemy turn!");
                }

                // Mark action as complete
                selectedMajorAction = 'Defensive Fire';
                updateSelectionSummary();
            } else {
                resultsDiv.innerHTML = `
                    <div class="alert alert-error" style="padding: 15px; background: #3a1a1a; border: 2px solid var(--lcars-red); border-radius: 5px;">
                        <strong style="color: var(--lcars-red);">ERROR:</strong> ${data.error}
                    </div>
                `;
                showErrorToast(data.error);
            }
        } catch (err) {
            resultsDiv.style.display = 'block';
            resultsDiv.innerHTML = `
                <div class="alert alert-error" style="padding: 15px; background: #3a1a1a; border: 2px solid var(--lcars-red); border-radius: 5px;">
                    <strong style="color: var(--lcars-red);">ERROR:</strong> ${err.message}
                </div>
            `;
            showErrorToast('Failed to activate Defensive Fire');
        }
    }

    function displayFireResults(data, targetIndex, focus, bonusDice, difficulty) {
        const resultsDiv = document.getElementById('fire-results');
        resultsDiv.style.display = 'block';

        if (!data.can_reroll) {
            activeMinorAction = null;
            updateFireMinorActionBanner();
            updateMajorActionHighlights();
            updateSelectionSummary();
        }

        const charDiceCount = 2 + bonusDice;
        const charRolls = data.rolls.slice(0, charDiceCount);
        const shipRoll = data.ship_roll;

        const charDiceHtml = charRolls.map((roll, index) => {
            let cls = 'dice-fail';
            if (roll === 1 || (focus && roll <= playerDiscs.security)) {
                cls = 'dice-crit';
            } else if (roll <= data.target_number) {
                cls = 'dice-success';
            } else if (roll === 20) {
                cls = 'dice-complication';
            }

            let rerollBtn = '';
            if (data.can_reroll && !data.rerolled) {
                rerollBtn = ` <button class="btn btn-small" onclick="rerollDie(${index})" style="font-size: 0.7em; padding: 2px 6px;">REROLL</button>`;
            }

            return `<span class="dice-result ${cls}">${roll}${rerollBtn}</span>`;
        }).join('');

        let shipDiceHtml = '';
        if (shipRoll !== null && shipRoll !== undefined) {
            let cls = 'dice-fail';
            if (shipRoll === 1) {
                cls = 'dice-crit';
            } else if (shipRoll <= data.ship_target_number) {
                cls = 'dice-success';
            } else if (shipRoll === 20) {
                cls = 'dice-complication';
            }
            shipDiceHtml = `<span class="dice-result ${cls}" style="border: 2px solid var(--lcars-tan);" title="Ship Assist (target ${data.ship_target_number})">${shipRoll}</span>`;
        }

        let html = `<h3>Attack Roll</h3>`;

        if (data.can_reroll && !data.rerolled) {
            html += `<div class="alert" style="background: #1a3a3a; border: 2px solid var(--lcars-blue); color: var(--lcars-blue); padding: 8px; margin-bottom: 10px;">
                <strong>TARGETING SOLUTION ACTIVE:</strong> Click REROLL to re-roll any die
            </div>`;
        }
        if (data.rerolled) {
            html += `<div class="alert" style="background: #1a3a1a; border: 2px solid var(--lcars-green); color: var(--lcars-green); padding: 8px; margin-bottom: 10px;">
                <strong>DIE RE-ROLLED</strong> (Targeting Solution consumed)
            </div>`;
        }

        html += `<div style="margin-bottom: 5px;"><strong>Character:</strong> ${charDiceHtml} (target <=${data.target_number})</div>`;
        html += `<div style="margin-bottom: 10px;"><strong>Ship Assist:</strong> ${shipDiceHtml} (target <=${data.ship_target_number})</div>`;
        html += `<p>${data.successes} total successes vs Difficulty ${difficulty}</p>`;

        if (data.complications > 0) {
            html += `<p style="color: var(--lcars-red);">${data.complications} complication(s)!</p>`;
        }

        if (data.succeeded) {
            html += `<div class="alert alert-success"><strong>HIT!</strong></div>`;
            html += `<div class="damage-report">`;
            html += `<h4>Damage Report</h4>`;
            html += `<p>Base Damage: ${data.base_damage}`;
            if (data.damage_bonus > 0) {
                html += ` <span style="color: var(--lcars-green);">(+${data.damage_bonus} bonus)</span>`;
            }
            if (data.effects_applied && data.effects_applied.length > 0) {
                html += `<br><small style="color: var(--lcars-green);">${data.effects_applied.join(', ')}</small>`;
            }
            html += `</p>`;
            if (data.resistance_reduction > 0) {
                html += `<p style="color: var(--lcars-tan);">Resistance (${data.target_resistance}): -${data.resistance_reduction}</p>`;
            }
            if (data.complication_reduction > 0) {
                html += `<p style="color: var(--lcars-tan);">Complications: -${data.complication_reduction}</p>`;
            }
            html += `<p><strong>Final Damage: ${data.total_damage}</strong></p>`;
            html += `<hr style="border-color: #444; margin: 8px 0;">`;
            html += `<p>Shield Damage: ${data.shield_damage}</p>`;
            if (data.hull_damage > 0) {
                html += `<p style="color: var(--lcars-red);">Hull Damage: ${data.hull_damage}</p>`;
            }
            html += `<p>Target Shields: ${data.target_shields_remaining}</p>`;
            if (data.breaches_caused > 0) {
                window.pendingBreaches = {
                    systems: data.systems_hit,
                    targetIndex: targetIndex,
                    canChooseSystem: data.can_choose_system,
                    revealed: []
                };

                html += `<div id="breach-resolution" style="margin-top: 10px; padding: 10px; background: #2a1a1a; border: 2px solid var(--lcars-red); border-radius: 5px;">`;
                html += `<p style="color: var(--lcars-red); font-weight: bold; margin-bottom: 10px;">WARNING: ${data.breaches_caused} BREACH(ES) CAUSED!</p>`;
                html += `<p style="margin-bottom: 10px; color: var(--lcars-tan);">Roll to determine which systems are hit:</p>`;

                data.systems_hit.forEach((system, index) => {
                    html += `<div id="breach-${index}" style="padding: 8px; background: #333; border-radius: 4px; margin-bottom: 5px;">`;
                    html += `<strong>Breach ${index + 1}:</strong> `;
                    html += `<span id="breach-result-${index}">`;

                    if (data.can_choose_system && index === 0) {
                        html += `<button class="btn" onclick="rollForBreach(${index})" style="padding: 5px 15px; margin-right: 10px;">ROLL FOR SYSTEM</button>`;
                        html += `<span style="color: var(--lcars-green);">or TARGET: </span>`;
                        html += `<select id="breach-choose-${index}" style="margin-right: 5px;">`;
                        ['comms', 'computers', 'engines', 'sensors', 'structure', 'weapons'].forEach(s => {
                            html += `<option value="${s}">${s.toUpperCase()}</option>`;
                        });
                        html += `</select>`;
                        html += `<button class="btn" onclick="chooseBreachSystem(${index})" style="padding: 5px 10px;">Choose</button>`;
                    } else {
                        html += `<button class="btn" onclick="rollForBreach(${index})" style="padding: 5px 15px;">ROLL FOR SYSTEM</button>`;
                    }

                    html += `</span>`;
                    html += `</div>`;
                });
                html += `</div>`;
            }

            if (data.target_status) {
                const status = data.target_status;

                if (status.destroyed_systems && status.destroyed_systems.length > 0) {
                    html += `<p style="color: var(--lcars-red); font-weight: bold;">WARNING: SYSTEMS DESTROYED: ${status.destroyed_systems.map(s => s.toUpperCase()).join(', ')}</p>`;
                }

                if (status.is_destroyed) {
                    html += `<div class="alert" style="background: var(--lcars-red); color: white; padding: 10px; margin-top: 10px; text-align: center;">`;
                    html += `<strong>TARGET DESTROYED!</strong>`;
                    html += `</div>`;
                } else if (status.warp_core_breach_risk) {
                    html += `<div class="alert" style="background: orange; color: black; padding: 10px; margin-top: 10px; text-align: center;">`;
                    html += `<strong>WARNING: WARP CORE BREACH IMMINENT!</strong><br>`;
                    html += `<small>Roll d20 at end of round. If > Engineering rating, reactor explodes!</small>`;
                    html += `</div>`;
                } else if (status.has_critical_damage) {
                    html += `<div class="alert" style="background: darkorange; color: white; padding: 10px; margin-top: 10px;">`;
                    html += `<strong>CRITICAL DAMAGE!</strong> Ship disabled (${status.total_breaches}/${status.scale} breaches). Next breach = destruction.`;
                    html += `</div>`;
                }
            }

            html += `</div>`;

            if (data.momentum_generated > 0) {
                html += `<p style="color: var(--lcars-blue);">+${data.momentum_generated} Momentum generated</p>`;
                document.getElementById('momentum').textContent = data.new_momentum;
                updateBonusDiceFromMomentum();
            }

            updateEnemyShipDisplay(targetIndex, data);
        } else {
            html += `<div class="alert alert-danger"><strong>MISS!</strong></div>`;
        }

        resultsDiv.innerHTML = html;
    }

    function updateEnemyShipDisplay(targetIndex, data) {
        const enemyItems = document.querySelectorAll('.enemy-ship-item');
        if (enemyItems[targetIndex]) {
            const item = enemyItems[targetIndex];

            const shieldsSpan = item.querySelector('.enemy-shields');
            const shieldsBar = item.querySelector('.enemy-shields-bar');
            if (shieldsSpan && data.target_shields_remaining !== undefined) {
                const maxShields = parseInt(shieldsSpan.textContent.split('/')[1]);
                shieldsSpan.textContent = `${data.target_shields_remaining} / ${maxShields}`;
                shieldsBar.style.width = `${(data.target_shields_remaining / maxShields) * 100}%`;
            }
        }
    }

    async function rollDice() {
        if (currentTurn !== 'player') {
            showErrorToast("It's not your turn!");
            return;
        }

        const attr = parseInt(document.getElementById('roll-attr').value);
        const disc = parseInt(document.getElementById('roll-disc').value);
        const diff = parseInt(document.getElementById('roll-diff').value);
        const bonus = parseInt(document.getElementById('roll-bonus').value);
        const focus = document.getElementById('roll-focus').checked;

        const hasShipAssist = currentActionConfig?.roll?.ship_assist_system && currentActionConfig?.roll?.ship_assist_department;

        let response;
        if (hasShipAssist) {
            const sysName = currentActionConfig.roll.ship_assist_system;
            const deptName = currentActionConfig.roll.ship_assist_department;
            const sysValue = shipSystems[sysName] || 7;
            const deptValue = shipDepts[deptName] || 2;

            response = await fetch('/api/roll-assisted', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    attribute: attr,
                    discipline: disc,
                    system: sysValue,
                    department: deptValue,
                    difficulty: diff,
                    bonus_dice: bonus,
                    focus: focus
                })
            });
        } else {
            response = await fetch('/api/roll', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    attribute: attr,
                    discipline: disc,
                    difficulty: diff,
                    bonus_dice: bonus,
                    focus: focus
                })
            });
        }
        const data = await response.json();

        document.getElementById('dice-results').style.display = 'block';

        const charDiceCount = hasShipAssist ? data.rolls.length - 1 : data.rolls.length;
        const shipAssistTarget = hasShipAssist ?
            (shipSystems[currentActionConfig.roll.ship_assist_system] || 7) + (shipDepts[currentActionConfig.roll.ship_assist_department] || 2) : 0;

        const diceDisplay = document.getElementById('dice-display');
        diceDisplay.innerHTML = data.rolls.map((roll, index) => {
            const isShipDie = hasShipAssist && index === data.rolls.length - 1;
            const targetNum = isShipDie ? shipAssistTarget : data.target_number;

            let cls = 'dice-fail';
            if (roll === 1) {
                cls = 'dice-crit';
            } else if (!isShipDie && focus && roll <= disc) {
                cls = 'dice-crit';
            } else if (roll <= targetNum) {
                cls = 'dice-success';
            } else if (roll === 20) {
                cls = 'dice-complication';
            }

            const label = isShipDie ? '<span style="font-size: 0.7em; display: block; color: var(--lcars-tan);">Ship</span>' : '';
            return `<span class="dice-result ${cls}">${roll}${label}</span>`;
        }).join('');

        const summary = document.getElementById('dice-summary');
        const resultClass = data.succeeded ? 'alert-success' : 'alert-danger';

        let effectMessage = '';

        if (currentAction?.name) {
            try {
                const execResponse = await fetch(`/api/encounter/${encounterId}/execute-action`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        action_name: currentAction.name,
                        attribute: attr,
                        discipline: disc,
                        difficulty: diff,
                        focus: focus,
                        bonus_dice: bonus,
                        roll_succeeded: data.succeeded,
                        roll_successes: data.successes,
                        roll_momentum: data.succeeded ? data.momentum_generated : 0,
                        roll_complications: data.complications,
                        roll_dice: data.rolls,
                        roll_target: data.target_number,
                        character_id: playerCharId
                    })
                });
                const execData = await execResponse.json();

                // Update momentum display (bonus dice may have been spent)
                if (execData.new_momentum !== undefined) {
                    document.getElementById('momentum').textContent = execData.new_momentum;
                    updateBonusDiceFromMomentum();
                }

                if (data.succeeded && execData.success && execData.effect_applied) {
                    effectMessage = `<br><span style="color: var(--lcars-green);">Effect applied: ${execData.effect_applied}</span>`;

                    if (execData.resistance_bonus) {
                        currentResistanceBonus += execData.resistance_bonus;
                        updateResistanceDisplay();
                    }
                }

                // Update turn display from execute-action response (handles turn advancement)
                if (currentAction && currentAction.type === 'major') {
                    if (execData.current_turn) {
                        // Update turn display immediately
                        updateTurnDisplay(execData.current_turn, execData.round, execData);

                        // Clear action state
                        activeMinorAction = null;
                        selectedMajorAction = null;
                        updateFireMinorActionBanner();
                        updateMajorActionHighlights();
                        updateSelectionSummary();
                        clearActionSelections('minor');
                        clearActionSelections('major');

                        // Hide action panels but keep results visible
                        document.getElementById('dice-panel').style.display = 'none';
                        document.getElementById('selection-summary').style.display = 'none';

                        // Add turn-over indicator to results (will be added after summary.innerHTML is set)
                        setTimeout(() => {
                            addTurnOverIndicator('dice-summary', execData.current_turn, execData);
                        }, 100);
                    }

                    if (execData.player_turns_used !== undefined) {
                        updateTurnCounters(
                            execData.player_turns_used, execData.player_turns_total,
                            execData.enemy_turns_used, execData.enemy_turns_total
                        );
                    }
                }
            } catch (err) {
                console.error('Failed to execute action:', err);
            }
        }

        summary.innerHTML = `
            <div class="alert ${resultClass}">
                <strong>${data.succeeded ? 'SUCCESS!' : 'FAILURE'}</strong><br>
                ${data.successes} successes vs Difficulty ${data.difficulty}<br>
                ${data.complications > 0 ? `<span style="color: darkred;">${data.complications} complication(s)!</span><br>` : ''}
                ${data.succeeded && data.momentum_generated > 0 ? `+${data.momentum_generated} Momentum generated` : ''}
                ${effectMessage}
            </div>
        `;
    }

    // Track pending attack state
    let pendingAttackData = null;
    let defensiveRollData = null;

    // Poll for turn changes (simple approach)
    setInterval(async () => {
        try {
            const response = await fetch(`/api/encounter/${encounterId}/status`);
            if (response.ok) {
                const data = await response.json();
                if (data.current_turn !== currentTurn) {
                    updateTurnDisplay(data.current_turn, data.round, data);
                }
                document.getElementById('momentum').textContent = data.momentum;
                document.getElementById('threat').textContent = data.threat;
                updateBonusDiceFromMomentum();

                // Update Reserve Power status if changed
                if (data.has_reserve_power !== hasReservePower) {
                    hasReservePower = data.has_reserve_power;
                    updateReservePowerDisplay();
                }

                // Update turn counters
                updateTurnCounters(
                    data.player_turns_used, data.player_turns_total,
                    data.enemy_turns_used, data.enemy_turns_total
                );

                // Check for pending attack that needs defensive roll
                if (data.pending_attack && !pendingAttackData) {
                    showPendingAttackPanel(data.pending_attack);
                } else if (!data.pending_attack && pendingAttackData) {
                    // Attack was resolved elsewhere (shouldn't happen normally)
                    hidePendingAttackPanel();
                }
            }
        } catch (e) {
            // Ignore errors during polling
        }
    }, 3000);

    function showPendingAttackPanel(attack) {
        pendingAttackData = attack;
        defensiveRollData = null;

        // Update panel with attack info
        document.getElementById('incoming-attacker').textContent = attack.attacker_name;
        document.getElementById('incoming-weapon').textContent = attack.weapon_name;

        // Set target numbers from player stats
        const defenderTarget = playerAttrs.daring + playerDiscs.security;
        const shipTarget = shipSystems.weapons + shipDepts.security;
        document.getElementById('incoming-defender-target').textContent = defenderTarget;
        document.getElementById('incoming-ship-target').textContent = shipTarget;

        // Reset roll state
        document.getElementById('incoming-roll-results').style.display = 'none';
        document.getElementById('incoming-attack-resolution').style.display = 'none';
        document.getElementById('incoming-attack-resolution').innerHTML = '';

        // Show panel
        const panel = document.getElementById('incoming-attack-panel');
        panel.style.display = 'block';
        panel.scrollIntoView({behavior: 'smooth'});

        // Play alert sound or show toast
        showErrorToast('INCOMING ATTACK! Roll your defensive dice!');
    }

    function hidePendingAttackPanel() {
        pendingAttackData = null;
        defensiveRollData = null;
        document.getElementById('incoming-attack-panel').style.display = 'none';
    }

    function rollDefensiveDice() {
        if (!pendingAttackData) return;

        // Roll 2d20 for character + 1d20 for ship
        const roll1 = Math.floor(Math.random() * 20) + 1;
        const roll2 = Math.floor(Math.random() * 20) + 1;
        const shipRoll = Math.floor(Math.random() * 20) + 1;

        const defenderTarget = playerAttrs.daring + playerDiscs.security;
        const shipTarget = shipSystems.weapons + shipDepts.security;

        // Calculate preliminary successes (server will recalculate)
        let successes = 0;
        let complications = 0;

        [roll1, roll2].forEach(roll => {
            if (roll === 1) successes += 2;
            else if (roll <= defenderTarget) successes += 1;
            if (roll === 20) complications += 1;
        });

        if (shipRoll === 1) successes += 2;
        else if (shipRoll <= shipTarget) successes += 1;
        if (shipRoll === 20) complications += 1;

        defensiveRollData = {
            defender_rolls: [roll1, roll2],
            ship_assist_roll: shipRoll,
        };

        // Format roll display
        const formatRoll = (roll, target) => {
            if (roll === 1) return `<span style="color: var(--lcars-green); font-weight: bold;">1 (CRIT!)</span>`;
            if (roll === 20) return `<span style="color: var(--lcars-red); font-weight: bold;">20 (COMP!)</span>`;
            if (roll <= target) return `<span style="color: var(--lcars-green);">${roll}</span>`;
            return `<span style="color: #888;">${roll}</span>`;
        };

        const detailsDiv = document.getElementById('incoming-roll-details');
        detailsDiv.innerHTML = `
            <div style="margin-bottom: 10px;">
                <strong>Character Rolls (Daring ${playerAttrs.daring} + Security ${playerDiscs.security} = Target ${defenderTarget}):</strong><br>
                Die 1: ${formatRoll(roll1, defenderTarget)} | Die 2: ${formatRoll(roll2, defenderTarget)}
            </div>
            <div style="margin-bottom: 10px;">
                <strong>Ship Assist (Weapons ${shipSystems.weapons} + Security ${shipDepts.security} = Target ${shipTarget}):</strong><br>
                Die: ${formatRoll(shipRoll, shipTarget)}
            </div>
            <div style="padding: 10px; background: #222; border-radius: 5px;">
                <strong>Your Successes:</strong> <span style="color: var(--lcars-green); font-size: 1.2em;">${successes}</span>
                ${complications > 0 ? `<br><span style="color: var(--lcars-red);">Complications: ${complications}</span>` : ''}
            </div>
        `;

        document.getElementById('incoming-roll-results').style.display = 'block';
    }

    async function submitDefensiveRoll() {
        if (!pendingAttackData || !defensiveRollData) {
            showErrorToast('Please roll your defensive dice first!');
            return;
        }

        try {
            const response = await fetch(`/api/encounter/${encounterId}/resolve-defensive-roll`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(defensiveRollData)
            });
            const data = await response.json();

            if (data.error) {
                showErrorToast(data.error);
                return;
            }

            // Display resolution results
            const resolutionDiv = document.getElementById('incoming-attack-resolution');
            resolutionDiv.style.display = 'block';

            let html = `
                <div style="padding: 15px; border-radius: 5px; ${data.defender_wins ? 'background: #1a3a1a; border: 2px solid var(--lcars-green);' : 'background: #3a1a1a; border: 2px solid var(--lcars-red);'}">
                    <h3 style="margin-top: 0; color: ${data.defender_wins ? 'var(--lcars-green)' : 'var(--lcars-red)'};">
                        ${data.defender_wins ? 'DEFENSE SUCCESSFUL!' : 'ATTACK HITS!'}
                    </h3>
                    <div style="display: flex; gap: 30px; margin-bottom: 15px;">
                        <div>
                            <strong>Your Successes:</strong> ${data.defender_successes}
                        </div>
                        <div>
                            <strong>Attacker Successes:</strong> ${data.attacker_successes}
                        </div>
                    </div>
                    <div style="margin-bottom: 10px;">
                        <strong>Attacker Rolls:</strong> ${data.attacker_rolls.join(', ')} (Target ${data.attacker_target})
                        + Ship ${data.attacker_ship_roll} (Target ${data.attacker_ship_target})
                    </div>
            `;

            if (data.defender_wins) {
                html += `<p style="color: var(--lcars-green);">${data.message}</p>`;

                if (data.can_counterattack && data.current_momentum >= 2) {
                    html += `
                        <div style="margin-top: 15px; padding: 10px; background: #222; border-radius: 5px;">
                            <p style="color: var(--lcars-orange);">
                                <strong>COUNTERATTACK AVAILABLE!</strong><br>
                                Spend 2 Momentum to counterattack with ${data.counterattack_weapon}?
                            </p>
                            <button class="btn" onclick="executeCounterattack(${data.counterattack_weapon_index}, ${data.counterattack_target_index})" style="background: var(--lcars-orange);">
                                COUNTERATTACK (2 Momentum)
                            </button>
                            <button class="btn" onclick="declineCounterattack()" style="background: #666;">
                                Decline
                            </button>
                        </div>
                    `;
                }
            } else {
                html += `
                    <p style="color: var(--lcars-red);">${data.message}</p>
                    <div style="margin-top: 10px;">
                        <strong>Damage Breakdown:</strong><br>
                        Base: ${data.base_damage} - Resistance: ${data.effective_resistance} = ${data.total_damage} damage<br>
                        Shield Damage: ${data.shield_damage} | Hull Damage: ${data.hull_damage}
                    </div>
                `;
                if (data.breaches_caused > 0) {
                    html += `<p style="color: var(--lcars-red);"><strong>BREACHES:</strong> ${data.systems_hit.join(', ').toUpperCase()}</p>`;
                }
            }

            html += '</div>';
            resolutionDiv.innerHTML = html;

            // Refresh action availability after taking damage (breaches may have occurred)
            if (data.breaches_caused > 0) {
                fetchActionAvailability();
            }

            // If no counterattack option or declined, hide panel after delay
            if (!data.can_counterattack || data.current_momentum < 2) {
                setTimeout(() => {
                    hidePendingAttackPanel();
                }, 5000);
            }

            // Clear pending attack data since it's resolved
            pendingAttackData = null;

        } catch (err) {
            showErrorToast('Failed to submit defensive roll: ' + err.message);
        }
    }

    async function executeCounterattack(weaponIndex, targetIndex) {
        try {
            const response = await fetch(`/api/encounter/${encounterId}/counterattack`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    weapon_index: weaponIndex,
                    target_index: targetIndex,
                    character_id: playerCharId
                })
            });
            const data = await response.json();

            const resolutionDiv = document.getElementById('incoming-attack-resolution');

            if (data.error) {
                resolutionDiv.innerHTML += `<p style="color: var(--lcars-red);">Counterattack failed: ${data.error}</p>`;
                return;
            }

            resolutionDiv.innerHTML += `
                <div style="margin-top: 15px; padding: 15px; background: #1a2a3a; border: 2px solid var(--lcars-blue); border-radius: 5px;">
                    <h3 style="margin-top: 0; color: var(--lcars-orange);">COUNTERATTACK!</h3>
                    <p>${data.message}</p>
                    ${data.total_damage > 0 ? `<p style="color: var(--lcars-green);">Dealt ${data.total_damage} damage!</p>` : ''}
                </div>
            `;

            document.getElementById('momentum').textContent = data.new_momentum;
            updateBonusDiceFromMomentum();
            showSuccessToast('Counterattack executed!');

            setTimeout(() => {
                hidePendingAttackPanel();
            }, 3000);

        } catch (err) {
            showErrorToast('Counterattack failed: ' + err.message);
        }
    }

    function declineCounterattack() {
        showSuccessToast('Counterattack declined');
        hidePendingAttackPanel();
    }
</script>
{% endblock %}
